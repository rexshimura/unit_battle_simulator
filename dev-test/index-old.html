<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="author" content="Rexshimura">
    <meta name="description" content="A web-based battle simulator where users can place and pit various units against each other in real-time.">

    <title>Unit Battle Simulator</title>

    <link rel="icon" type="image/x-icon" href="icon/app.ico">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a1a1a;
            color: #f0f0f0;
            cursor: default;
        }
        .glass-panel {
            background: rgba(40, 40, 40, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }
        .unit-btn {
            transition: all 0.2s ease-in-out;
        }
        .unit-btn.selected {
            background-color: #a78bfa;
            color: #1a1a1a;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.5);
        }
        /* This makes the description text dark when selected */
        .unit-btn.selected p {
            color: #1a1a1a;
        }
        .action-btn {
            transition: all 0.2s ease-in-out;
        }
        .action-btn:hover {
            transform: scale(1.05);
        }
        .action-btn.active {
            background-color: #8b5cf6;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        .action-btn.remove.active {
             background-color: #ef4444;
             box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }
        .speed-btn.selected {
            background-color: #8b5cf6;
            color: #f0f0f0;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        #gameCanvas {
            cursor: crosshair;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        .status-message {
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transition: opacity 0.5s ease-in-out;
        }
        .unit-list::-webkit-scrollbar, #stats-panel-content::-webkit-scrollbar { width: 8px; }
        .unit-list::-webkit-scrollbar-track, #stats-panel-content::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 10px; }
        .unit-list::-webkit-scrollbar-thumb, #stats-panel-content::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 10px; }
        .unit-list::-webkit-scrollbar-thumb:hover, #stats-panel-content::-webkit-scrollbar-thumb:hover { background: #5c5c5c; }

        /* Tooltip Styles */
        #unit-tooltip, #inspect-tooltip {
            position: fixed;
            display: none;
            padding: 12px;
            z-index: 100;
            pointer-events: none;
            transition: opacity 0.2s;
            width: 280px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        /* Role Sorter Styles */
        .role-btn {
            transition: all 0.2s ease-in-out;
            background-color: rgba(255, 255, 255, 0.1);
        }
        .role-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .role-btn.selected {
            background-color: #a78bfa;
            color: #1a1a1a;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.5);
        }

        /* Stats Panel Styles */
        #stats-panel {
            position: fixed;
            top: 0;
            right: -450px; /* Start off-screen */
            width: 400px;
            height: 100%;
            z-index: 60;
            transition: right 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }
        #stats-panel.open {
            right: 0;
        }
        #stats-panel-content {
            padding-right: 10px; /* Space for scrollbar */
        }
        .stat-bar-container {
            width: 100%;
            background-color: rgba(0,0,0,0.3);
            border-radius: 0.25rem;
            overflow: hidden;
            height: 14px;
            position: relative;
        }
        .stat-bar {
            height: 100%;
            transition: width 0.3s ease-in-out;
            border-radius: 0.25rem;
        }
        .stat-bar-label {
            position: absolute;
            left: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
         .stats-filter-btn {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            transition: all 0.2s ease-in-out;
            background-color: rgba(255, 255, 255, 0.1);
        }
        .stats-filter-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .stats-filter-btn.selected {
            background-color: #a78bfa;
            color: #1a1a1a;
            font-weight: bold;
        }
        .summary-bar {
             height: 8px;
             border-radius: 4px;
        }
        .progress-bar {
            background-color: rgba(0,0,0,0.3);
            border-radius: 9999px;
            overflow: hidden;
            height: 10px;
        }
        .progress-bar-inner {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="unit-tooltip" class="glass-panel"></div>
    <div id="inspect-tooltip" class="glass-panel"></div>
    
    <div id="stats-panel" class="glass-panel">
        <div class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 class="text-xl font-bold text-violet-300">Battle Statistics</h2>
            <button id="close-stats-btn" class="text-gray-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="stats-panel-content" class="overflow-y-auto flex-grow">
            </div>
    </div>


    <div id="game-container" class="w-full h-full flex flex-col p-4 gap-4">
        <div class="glass-panel p-4 w-full flex-shrink-0 flex justify-between items-center">
            <div class="flex items-center gap-4">
                <h1 id="version-header" class="text-2xl font-bold text-violet-300">Unit Battle Simulator</h1>
            </div>
            <div class="text-right flex gap-4 items-center">
                <button id="inspect-unit-btn" data-tooltip-title="Inspect Unit" data-tooltip-desc="Hover over or click a unit to see its detailed stats in real-time." class="action-btn p-2 rounded-full bg-gray-700 hover:bg-gray-600 shadow-lg text-white flex items-center gap-2 px-3">
                     <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                     <span class="text-xs text-gray-400 font-mono -ml-1">[Q]</span>
                </button>
                
                <button id="show-stats-btn" data-tooltip-title="Battle Statistics" data-tooltip-desc="Opens a panel showing detailed performance stats for all units in the battle." class="action-btn p-2 rounded-full bg-gray-700 hover:bg-gray-600 shadow-lg text-white flex items-center gap-2 px-3">
                     <svg class="w-6 h-6 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                     <span class="text-xs text-gray-400 font-mono -ml-1">[S]</span>
                </button>

                <button id="toggle-range-btn" data-tooltip-title="Toggle Range Preview" data-tooltip-desc="Shows or hides the attack range circles for all units on the battlefield." class="action-btn p-2 rounded-full bg-gray-700 hover:bg-gray-600 shadow-lg text-white flex items-center gap-2 px-3">
                    <img id="eye-icon" src="icon/icon_eye_open.svg" alt="Eye Open" class="w-6 h-6 hidden pointer-events-none">
                    <img id="eye-off-icon" src="icon/icon_eye_closed.svg" alt="Eye Closed" class="w-6 h-6 pointer-events-none">
                    <span class="text-xs text-gray-400 font-mono -ml-1">[R]</span>
                </button>

                <button id="remove-unit-btn" data-tooltip-title="Remove Unit" data-tooltip-desc="Activates remove mode. Click on a unit on the field to delete it." class="action-btn remove p-2 rounded-full bg-gray-700 hover:bg-gray-600 shadow-lg text-white flex items-center gap-2 px-3">
                    <img src="icon/icon_remove.svg" alt="Remove" class="w-6 h-6 pointer-events-none">
                    <span class="text-xs text-gray-400 font-mono -ml-1">[X]</span>
                </button>

                <p class="text-lg font-bold text-blue-400">Blue: <span id="blue-count">0</span></p>
                <p class="text-lg font-bold text-red-400">Red: <span id="red-count">0</span></p>
            </div>
        </div>

        <div class="w-full flex-grow flex flex-col md:flex-row gap-4 min-h-0">
            <div class="glass-panel p-6 w-full md:w-64 flex flex-col">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-600 pb-2 flex-shrink-0">Place Units</h2>
                
                <div id="role-sorter" class="flex justify-around mb-4 border-b border-gray-600 pb-2">
                     <button data-role="all" class="role-btn p-2 rounded-full selected" data-tooltip-title="All Units" data-tooltip-desc="Show all available units.">
                        <img src="icon/icon_all.svg" alt="All" class="w-6 h-6 pointer-events-none">
                    </button>
                    <button data-role="Melee" class="role-btn p-2 rounded-full" data-tooltip-title="Melee Units" data-tooltip-desc="Filter for units that fight up close.">
                        <img src="icon/icon_melee.svg" alt="Melee" class="w-6 h-6 pointer-events-none">
                    </button>
                    <button data-role="Ranged" class="role-btn p-2 rounded-full" data-tooltip-title="Ranged Units" data-tooltip-desc="Filter for units that attack from a distance.">
                        <img src="icon/icon_range.svg" alt="Ranged" class="w-6 h-6 pointer-events-none">
                    </button>
                    <button data-role="Tank" class="role-btn p-2 rounded-full" data-tooltip-title="Tank Units" data-tooltip-desc="Filter for durable units that absorb damage.">
                        <img src="icon/icon_tank.svg" alt="Tank" class="w-6 h-6 pointer-events-none">
                    </button>
                    <button data-role="Support" class="role-btn p-2 rounded-full" data-tooltip-title="Support Units" data-tooltip-desc="Filter for units that heal or support allies.">
                        <img src="icon/icon_support.svg" alt="Support" class="w-6 h-6 pointer-events-none">
                    </button>
                </div>

                <div class="space-y-3 unit-list flex-grow min-h-0 overflow-y-auto pr-2">
                    <button data-unit-type="swordsman" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Swordsman</p><p class="text-xs text-gray-400">Fast, Melee Attack</p>
                    </button>
                    <button data-unit-type="guardian" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Guardian</p><p class="text-xs text-gray-400">Tough, hits and deflects</p>
                    </button>
                     <button data-unit-type="spearman" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Spearman</p><p class="text-xs text-gray-400">Melee, long reach</p>
                    </button>
                    <button data-unit-type="musketeer" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Musketeer</p><p class="text-xs text-gray-400">Slow, Ranged Shot</p>
                    </button>
                    <button data-unit-type="archer" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Archer</p><p class="text-xs text-gray-400">Shoots sharp arrows</p>
                    </button>
                     <button data-unit-type="cryomancer" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Cryomancer</p><p class="text-xs text-gray-400">Slows and freezes enemies</p>
                    </button>
                    <button data-unit-type="flamecaller" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Flamecaller</p><p class="text-xs text-gray-400">Ranged, AOE damage</p>
                    </button>
                     <button data-unit-type="wizard" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Wizard</p><p class="text-xs text-gray-400">Ranged, chain electric</p>
                    </button>
                    <button data-unit-type="priest" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Priest</p><p class="text-xs text-gray-400">Heals & armors allies</p>
                    </button>
                    <button data-unit-type="bard" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Bard</p><p class="text-xs text-gray-400">Boosts nearby allies</p>
                    </button>
                    <button data-unit-type="druid" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Druid</p><p class="text-xs text-gray-400">Links to heal allies</p>
                    </button>
                    <button data-unit-type="alchemist" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Alchemist</p><p class="text-xs text-gray-400">Throws debilitating potions</p>
                    </button>
                    <button data-unit-type="sledgehammer" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Sledgehammer</p><p class="text-xs text-gray-400">Crits armored units</p>
                    </button>
                    <button data-unit-type="duelist" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Duelist</p><p class="text-xs text-gray-400">Fast, with burst attacks</p>
                    </button>
                    <button data-unit-type="rockgolem" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Rock Golem</p><p class="text-xs text-gray-400">Tanky, AOE stun</p>
                    </button>
                    <button data-unit-type="troll" class="unit-btn w-full text-left p-3 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <p class="font-bold">Troll</p><p class="text-xs text-gray-400">Huge, ignores defense</p>
                    </button>
                </div>
                <div class="mt-auto flex-shrink-0">
                    <div class="mt-6 pt-4 border-t border-gray-600 flex justify-around items-center">
                         <button id="start-battle-btn" data-tooltip-title="Start / Stop Battle" data-tooltip-desc="Start the simulation. Click again while running to stop and completely clear the field." class="action-btn p-3 rounded-full bg-green-600 hover:bg-green-500 shadow-lg text-white">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                         </button>
                         <button id="pause-btn" data-tooltip-title="Pause / Resume" data-tooltip-desc="Pause or resume the current battle simulation." class="action-btn p-3 rounded-full bg-yellow-600 hover:bg-yellow-500 shadow-lg text-white">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                         </button>
                         <button id="reset-btn" data-tooltip-title="Reset Positions" data-tooltip-desc="Resets all units to their positions at the start of the last battle." class="action-btn p-3 rounded-full bg-red-600 hover:bg-red-500 shadow-lg text-white">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                         </button>
                    </div>
                    <div class="mt-4 pt-4 border-t border-gray-600">
                        <h3 class="text-lg font-bold mb-2 text-center">Game Speed</h3>
                        <div id="speed-controls" class="grid grid-cols-4 gap-2">
                            <button class="speed-btn action-btn p-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-xs" data-speed="0.5">0.5x</button>
                            <button class="speed-btn action-btn p-2 rounded-lg bg-gray-700 hover:bg-gray-600 selected text-xs" data-speed="1.0">1.0x</button>
                            <button class="speed-btn action-btn p-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-xs" data-speed="1.5">1.5x</button>
                            <button class="speed-btn action-btn p-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-xs" data-speed="2.0">2.0x</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="canvas-container" class="relative flex-grow">
                <canvas id="gameCanvas" class="w-full h-full"></canvas>
                <div id="selection-message" class="status-message absolute top-5 left-5 text-lg font-bold text-violet-300 pointer-events-none opacity-0 transition-opacity"></div>
                <div id="status-message" class="status-message absolute inset-0 flex items-center justify-center text-5xl font-bold text-white pointer-events-none opacity-0 transition-opacity"></div>
                <div id="remove-message" class="status-message absolute top-5 inset-x-0 flex items-center justify-center text-2xl font-bold text-red-400 pointer-events-none opacity-0 transition-opacity"></div>
                <div id="inspect-message" class="status-message absolute top-5 inset-x-0 flex items-center justify-center text-2xl font-bold text-violet-300 pointer-events-none opacity-0 transition-opacity"></div>
                <button id="stop-tracking-btn" class="hidden absolute top-4 right-4 action-btn bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-full">Stop Tracking</button>
            </div>
        </div>
    </div>
    
    <script>
        // =======================================================
        // === BATTLE STATISTICS LOGIC ===
        // =======================================================

        /**
         * Updates the content of the battle statistics panel based on the current state of the battle.
         */
        function updateStatsPanel() {
            const statsPanelContent = document.getElementById('stats-panel-content');
            if (!statsPanelContent) return;

            const blueTeamUnits = allUnitsThisRound.filter(u => u.team === 1);
            const redTeamUnits = allUnitsThisRound.filter(u => u.team === 2);

            const blueTotalDamage = blueTeamUnits.reduce((sum, u) => sum + u.damageDealt, 0);
            const redTotalDamage = redTeamUnits.reduce((sum, u) => sum + u.damageDealt, 0);
            const blueTotalHealing = blueTeamUnits.reduce((sum, u) => sum + u.healingDone, 0);
            const redTotalHealing = redTeamUnits.reduce((sum, u) => sum + u.healingDone, 0);
            
            const totalBattleDamage = Math.max(1, blueTotalDamage + redTotalDamage);
            const totalBattleHealing = Math.max(1, blueTotalHealing + redTotalHealing);
            const totalBattleDamageTaken = Math.max(1, allUnitsThisRound.reduce((sum, u) => sum + u.damageTaken, 0));

            const blueDamagePercent = (blueTotalDamage / totalBattleDamage) * 100;
            const redDamagePercent = (redTotalDamage / totalBattleDamage) * 100;
            const blueHealingPercent = (blueTotalHealing / totalBattleHealing) * 100;
            const redHealingPercent = (redTotalHealing / totalBattleHealing) * 100;

            let html = `
                <div class="mb-4">
                    <h3 class="text-lg font-bold text-blue-400 mb-2">Blue Team</h3>
                    <div class="space-y-2 text-xs">
                        <div>
                            <p class="text-gray-300 mb-1 flex justify-between"><span>Damage Dealt: ${blueDamagePercent.toFixed(1)}%</span> <span>${Math.round(blueTotalDamage)}</span></p>
                            <div class="stat-bar-container"><div class="stat-bar bg-blue-500" style="width: ${blueDamagePercent}%"></div></div>
                        </div>
                        <div>
                            <p class="text-gray-300 mb-1 flex justify-between"><span>Healing Done: ${blueHealingPercent.toFixed(1)}%</span> <span>${Math.round(blueTotalHealing)}</span></p>
                            <div class="stat-bar-container"><div class="stat-bar bg-green-500" style="width: ${blueHealingPercent}%"></div></div>
                        </div>
                    </div>
                </div>
                 <div class="mb-4">
                    <h3 class="text-lg font-bold text-red-400 mb-2">Red Team</h3>
                     <div class="space-y-2 text-xs">
                        <div>
                             <p class="text-gray-300 mb-1 flex justify-between"><span>Damage Dealt: ${redDamagePercent.toFixed(1)}%</span> <span>${Math.round(redTotalDamage)}</span></p>
                            <div class="stat-bar-container"><div class="stat-bar bg-red-500" style="width: ${redDamagePercent}%"></div></div>
                        </div>
                        <div>
                             <p class="text-gray-300 mb-1 flex justify-between"><span>Healing Done: ${redHealingPercent.toFixed(1)}%</span> <span>${Math.round(redTotalHealing)}</span></p>
                            <div class="stat-bar-container"><div class="stat-bar bg-green-500" style="width: ${redHealingPercent}%"></div></div>
                        </div>
                    </div>
                </div>
                <div id="unit-performance-section" class="border-t border-gray-600 pt-4">
                     <div class="flex justify-between items-center mb-3">
                         <h3 class="text-lg font-bold">Unit Performance</h3>
                         <div class="flex items-center gap-2">
                            <button class="stats-filter-btn ${isSummarizedView ? 'selected' : ''}" data-action="toggle-summary">Summarize</button>
                         </div>
                     </div>
                     <div id="stats-filter-controls" class="flex items-center gap-2 mb-3">
                        <button class="stats-filter-btn ${statsFilter === 'all' ? 'selected' : ''}" data-filter="all">All</button>
                        <button class="stats-filter-btn ${statsFilter === 'alive' ? 'selected' : ''}" data-filter="alive">Alive</button>
                        <button class="stats-filter-btn ${statsFilter === 'defeated' ? 'selected' : ''}" data-filter="defeated">Defeated</button>
                     </div>
                    <div class="space-y-3">
            `;

            let filteredUnits = [...allUnitsThisRound];
            if (statsFilter === 'alive') {
                filteredUnits = filteredUnits.filter(u => u.hp > 0);
            } else if (statsFilter === 'defeated') {
                filteredUnits = filteredUnits.filter(u => u.hp <= 0);
            }

            filteredUnits.sort((a,b) => (b.damageDealt + b.healingDone) - (a.damageDealt + a.healingDone)).forEach(unit => {
                const teamColor = unit.team === 1 ? 'text-blue-300' : 'text-red-300';
                const unitName = UNIT_SPECS[unit.type].name;
                const status = unit.hp > 0 ? '' : ' (Defeated)';
                
                if (isSummarizedView) {
                    html += `
                    <div class="p-2 rounded-lg bg-gray-800/50">
                        <div class="flex justify-between items-center text-sm">
                           <p class="font-bold ${teamColor}">${unitName}${status}</p>
                           <span class="text-xs text-gray-400">Kills: ${unit.kills}</span>
                        </div>
                        <div class="space-y-1 mt-2 text-xs grid grid-cols-[auto,1fr] gap-x-2 items-center">
                            <span class="text-gray-400">Dealt:</span>
                            <div class="w-full bg-gray-900/50 rounded-full"><div class="summary-bar bg-orange-400" style="width: ${ (unit.damageDealt / totalBattleDamage) * 100}%" title="Damage Dealt: ${Math.round(unit.damageDealt)}"></div></div>
                            <span class="text-gray-400">Taken:</span>
                            <div class="w-full bg-gray-900/50 rounded-full"><div class="summary-bar bg-red-400" style="width: ${ (unit.damageTaken / totalBattleDamageTaken) * 100}%" title="Damage Taken: ${Math.round(unit.damageTaken)}"></div></div>
                             ${ unit.healingDone > 0 ? `<span class="text-gray-400">Heal:</span><div class="w-full bg-gray-900/50 rounded-full"><div class="summary-bar bg-green-400" style="width: ${ (unit.healingDone / totalBattleHealing) * 100}%" title="Healing Done: ${Math.round(unit.healingDone)}"></div></div>` : ''}
                        </div>
                    </div>
                    `;
                } else {
                     const damageDealtPercent = totalBattleDamage > 1 ? `(${( (unit.damageDealt / totalBattleDamage) * 100).toFixed(1)}%)` : '';
                     const healingDonePercent = totalBattleHealing > 1 ? `(${( (unit.healingDone / totalBattleHealing) * 100).toFixed(1)}%)` : '';
                     const damageTakenPercent = totalBattleDamageTaken > 1 ? `(${( (unit.damageTaken / totalBattleDamageTaken) * 100).toFixed(1)}%)` : '';
                     
                     html += `
                        <div class="p-3 rounded-lg bg-gray-800/50">
                            <p class="font-bold ${teamColor}">${unitName}${status}</p>
                            <div class="text-xs grid grid-cols-2 gap-x-4 gap-y-1 mt-2 text-gray-300">
                               <span>Damage Dealt:</span> <span class="text-white font-semibold">${Math.round(unit.damageDealt)} ${damageDealtPercent}</span>
                               <span>Healing Done:</span> <span class="text-white font-semibold">${Math.round(unit.healingDone)} ${healingDonePercent}</span>
                               <span>Damage Taken:</span> <span class="text-white font-semibold">${Math.round(unit.damageTaken)} ${damageTakenPercent}</span>
                               <span>Kills:</span> <span class="text-white font-semibold">${unit.kills}</span>
                            </div>
                        </div>
                    `;
                }
            });

            html += `</div></div>`;
            statsPanelContent.innerHTML = html;
        }

        /**
         * Initializes all event listeners related to the statistics panel.
         */
        function initStatsEventListeners() {
            const showStatsBtn = document.getElementById('show-stats-btn');
            const statsPanel = document.getElementById('stats-panel');
            const closeStatsBtn = document.getElementById('close-stats-btn');
            const statsPanelContent = document.getElementById('stats-panel-content');

            showStatsBtn.addEventListener('click', () => {
                updateStatsPanel();
                statsPanel.classList.add('open');
            });

            closeStatsBtn.addEventListener('click', () => {
                statsPanel.classList.remove('open');
            });
            
            statsPanelContent.addEventListener('click', (e) => {
                const filterBtn = e.target.closest('[data-filter]');
                const summaryBtn = e.target.closest('[data-action="toggle-summary"]');

                if (filterBtn) {
                    statsFilter = filterBtn.dataset.filter;
                }
                if (summaryBtn) {
                    isSummarizedView = !isSummarizedView;
                }
                if (filterBtn || summaryBtn) {
                     updateStatsPanel();
                }
            });
        }

        /**
         * Initializes all hotkey event listeners for the application.
         */
        function initHotkeys() {
            document.addEventListener('keydown', (e) => {
                // We don't want hotkeys to fire if a user is typing in an input field in the future
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (e.key.toLowerCase()) {
                    case 'q':
                        document.getElementById('inspect-unit-btn').click();
                        break;
                    case 's':
                        const statsPanel = document.getElementById('stats-panel');
                        if (statsPanel.classList.contains('open')) {
                           document.getElementById('close-stats-btn').click();
                        } else {
                           document.getElementById('show-stats-btn').click();
                        }
                        break;
                    case 'r':
                        document.getElementById('toggle-range-btn').click();
                        break;
                    case 'x':
                        document.getElementById('remove-unit-btn').click();
                        break;
                }
            });
        }

        // =======================================================
        // === UI INTERACTION LOGIC ===
        // =======================================================
        
        /**
         * Updates the tooltip that shows detailed real-time stats for a specific unit.
         * @param {Unit} unit - The unit to display information for.
         * @param {MouseEvent} event - The mouse event, used for positioning the tooltip.
         */
        function updateInspectTooltip(unit, event) {
            const inspectTooltip = document.getElementById('inspect-tooltip');
            if (!unit || !inspectTooltip) {
                if(inspectTooltip) inspectTooltip.style.display = 'none';
                return;
            }
            const stats = UNIT_SPECS[unit.type];
            const tagsHTML = stats.tags.map(tag => `<span class="bg-gray-600 text-violet-300 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${tag}</span>`).join('');
            
            let currentCooldown = unit.attackCooldown;
            let currentDamage = unit.attackDamage;
            if (unit.buffs.bard && Date.now() < unit.buffs.bard.expires) {
                currentCooldown /= (1 + unit.buffs.bard.attackSpeedBoost);
                currentDamage *= (1 + unit.buffs.bard.damageBoost);
            }
            const cooldownProgress = isBattleStarted ? Math.min(1, (Date.now() - unit.lastAttackTime) / (currentCooldown / gameSpeed)) * 100 : 0;
            const healthPercentage = (unit.hp / unit.maxHp) * 100;
            const healthColor = healthPercentage > 50 ? 'bg-green-500' : healthPercentage > 25 ? 'bg-yellow-500' : 'bg-red-500';
            const armorPercentage = (unit.armor / unit.maxHp) * 100; // Show armor relative to max HP

            // ================= NEW: Expanded Tooltip HTML =================
            let extraStatsHTML = `
                ${stats.attackDamage > 0 ? `<span class="text-gray-400">Damage:</span> <span class="text-white">${stats.attackDamage}</span>` : ''}
                ${stats.attackRange > 0 ? `<span class="text-gray-400">Range:</span> <span class="text-white">${stats.attackRange}</span>` : ''}
                ${stats.speed > 0 ? `<span class="text-gray-400">Speed:</span> <span class="text-white">${stats.speed}</span>` : ''}
                ${stats.healAmount > 0 ? `<span class="text-gray-400">Heal:</span> <span class="text-white">${stats.healAmount}</span>` : ''}
                ${stats.stunDuration > 0 ? `<span class="text-gray-400">Stun:</span> <span class="text-white">${stats.stunDuration / 1000}s</span>` : ''}
            `;

            inspectTooltip.innerHTML = `
                <div class="flex justify-between items-start">
                    <h3 class="text-lg font-bold ${unit.team === 1 ? 'text-blue-300' : 'text-red-300'} mb-2">${stats.name}</h3>
                     <span class="text-sm font-semibold text-gray-300">${Math.ceil(unit.hp)} + <span class="text-cyan-300">${Math.ceil(unit.armor)}</span> / ${unit.maxHp}</span>
                </div>
                
                <div class="stat-bar-container mb-2 h-3 relative">
                     <div class="stat-bar bg-cyan-500/50 absolute top-0 left-0" style="width: ${armorPercentage}%"></div>
                    <div class="stat-bar ${healthColor}" style="width: ${healthPercentage}%"></div>
                </div>

                <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm mb-2">
                    ${extraStatsHTML}
                </div>
                 <div class="text-sm">
                    <span class="text-gray-400">Cooldown:</span>
                    <div class="progress-bar mt-1">
                        <div class="progress-bar-inner bg-yellow-400" style="width: ${cooldownProgress}%"></div>
                    </div>
                 </div>
                <div class="mt-3 pt-2 border-t border-gray-600">
                    ${tagsHTML}
                </div>
            `;
            // ==============================================================

            inspectTooltip.style.display = 'block';
            if (trackedUnit) {
                 const rect = canvas.getBoundingClientRect();
                 inspectTooltip.style.left = `${rect.left + unit.x + 20}px`;
                 inspectTooltip.style.top = `${rect.top + unit.y - 40}px`;
            } else if (event) {
                 inspectTooltip.style.left = `${event.clientX + 15}px`;
                 inspectTooltip.style.top = `${event.clientY + 15}px`;
            }
        }

        /**
         * Initializes all event listeners for the main UI controls (inspect, remove, toggle range).
         */
        function initInteractionEventListeners() {
            const toggleRangeBtn = document.getElementById('toggle-range-btn');
            const eyeIcon = document.getElementById('eye-icon');
            const eyeOffIcon = document.getElementById('eye-off-icon');
            const removeUnitBtn = document.getElementById('remove-unit-btn');
            const inspectUnitBtn = document.getElementById('inspect-unit-btn');
            const stopTrackingBtn = document.getElementById('stop-tracking-btn');
            const canvas = document.getElementById('gameCanvas');
            const removeMessage = document.getElementById('remove-message');
            const inspectMessage = document.getElementById('inspect-message');
            
            toggleRangeBtn.addEventListener('click', () => {
                showRangePreview = !showRangePreview;
                eyeIcon.classList.toggle('hidden', !showRangePreview);
                eyeOffIcon.classList.toggle('hidden', showRangePreview);
            });

            removeUnitBtn.addEventListener('click', () => {
                isRemoveModeActive = !isRemoveModeActive;
                removeUnitBtn.classList.toggle('active', isRemoveModeActive);
                canvas.style.cursor = isRemoveModeActive ? 'pointer' : 'crosshair';
                if (isRemoveModeActive) {
                    if(isInspectModeActive) inspectUnitBtn.click();
                    selectedUnit = null;
                    document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
                    removeMessage.textContent = 'Click a unit to remove';
                    removeMessage.style.opacity = 1;
                } else {
                    removeMessage.style.opacity = 0;
                    unitToHighlight = null;
                }
            });
            
            inspectUnitBtn.addEventListener('click', () => {
                isInspectModeActive = !isInspectModeActive;
                inspectUnitBtn.classList.toggle('active', isInspectModeActive);
                canvas.style.cursor = isInspectModeActive ? 'pointer' : 'crosshair';
                if(isInspectModeActive) {
                    if(isRemoveModeActive) removeUnitBtn.click();
                    inspectMessage.textContent = 'Hover or Click a unit to observe';
                    inspectMessage.style.opacity = 1;
                } else {
                    inspectMessage.style.opacity = 0;
                    trackedUnit = null;
                    stopTrackingBtn.classList.add('hidden');
                    document.getElementById('inspect-tooltip').style.display = 'none';
                }
            });
            
            stopTrackingBtn.addEventListener('click', () => {
                trackedUnit = null;
                stopTrackingBtn.classList.add('hidden');
                inspectMessage.style.opacity = 1;
                document.getElementById('inspect-tooltip').style.display = 'none';
            });
        }


        // =======================================================
        // === MAIN GAME LOGIC ===
        // =======================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const blueCountDisplay = document.getElementById('blue-count');
        const redCountDisplay = document.getElementById('red-count');
        
        const startBattleBtn = document.getElementById('start-battle-btn');
        const resetBtn = document.getElementById('reset-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const speedControls = document.getElementById('speed-controls');
        const statusMessage = document.getElementById('status-message');
        const selectionMessage = document.getElementById('selection-message');
        const tooltip = document.getElementById('unit-tooltip');
        
        const roleSorter = document.getElementById('role-sorter');
        
        const playIconSVG = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
        const stopIconSVG = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>`;
        const pauseIconSVG = `<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;

        // CONFIG: New global settings for armor and crits
        const ARMOR_DAMAGE_REDUCTION_PERCENT = 0.50; // 50% damage reduction

        const UNIT_SPECS = {
            'swordsman':   { name: 'Swordsman',   tags: ['Melee', 'Basic'],  hp: 100, speed: 1.0,  attackDamage: 13.5, attackRange: 40,   attackCooldown: 720,  color: { team1: '#60a5fa', team2: '#f87171' } },
            'guardian':    { name: 'Guardian',    tags: ['Tank', 'Melee'],   hp: 200, speed: 0.4,  attackDamage: 10,   attackRange: 35,   attackCooldown: 1200, color: { team1: '#60a5fa', team2: '#f87171' }, deflectChance: 0.70 },
            'spearman':    { name: 'Spearman',    tags: ['Melee'],           hp: 90,  speed: 0.9,  attackDamage: 10,   attackRange: 80,   attackCooldown: 470,  color: { team1: '#60a5fa', team2: '#f87171' } },
            'musketeer':   { name: 'Musketeer',   tags: ['Ranged', 'Basic'], hp: 50,  speed: 0.5,  attackDamage: 18,   attackRange: 600,  attackCooldown: 2450, color: { team1: '#60a5fa', team2: '#f87171' } },
            'archer':      { name: 'Archer',      tags: ['Ranged', 'Basic'], hp: 60,  speed: 0.7,  attackDamage: 12,   attackRange: 420,  attackCooldown: 1000, color: { team1: '#60a5fa', team2: '#f87171' } },
            'flamecaller': { name: 'Flamecaller', tags: ['Ranged'],          hp: 60,  speed: 0.6,  attackDamage: 25,   attackRange: 350,  attackCooldown: 5500, color: { team1: '#54c7d1', team2: '#e39a5b' }, aoeRadius: 80, aoeDamage: 25 },
            'wizard':      { name: 'Wizard',      tags: ['Ranged'],          hp: 70,  speed: 0.7,  attackDamage: 2,    attackRange: 300,  attackCooldown: 400,  color: { team1: '#a78bfa', team2: '#fde047' }, chainTargets: 5, chainRange: 150 },
            'cryomancer':  { name: 'Cryomancer',  tags: ['Ranged', 'Support'], hp: 80, speed: 0.6, attackDamage: 15,   attackRange: 300, attackCooldown: 2000, color: { team1: '#a5f3fc', team2: '#67e8f9' }, specialTriggerCount: 2, waveDamage: 3, freezeStacksApplied: 1, freezeTriggerCount: 3, freezeDuration: 2500, chillDuration: 5000 },
            'priest':      { name: 'Priest',      tags: ['Support'],         hp: 70,  speed: 0.7,  attackDamage: 0,    attackRange: 0,    attackCooldown: 4000, color: { team1: '#c1f3f5', team2: '#f2e56b' }, healAmount: 25, healRadius: 300, lightHealTriggerCount: 4, lightHealArmorBonus: 25, lightHealArmorDuration: 5000 },
            'bard':        { name: 'Bard',        tags: ['Support'],         hp: 80,  speed: 0.8,  attackDamage: 0,    attackRange: 0,    attackCooldown: 2000, color: { team1: '#60a5fa', team2: '#f87171' }, buffRadius: 250, damageBoost: 0.20, attackSpeedBoost: 0.50, buffDuration: 2200 },
            'druid':       { name: 'Druid',       tags: ['Support'],         hp: 90,  speed: 0.7,  attackDamage: 0,    attackRange: 300,  attackCooldown: 1000, color: { team1: '#86efac', team2: '#fcd34d' }, healAmount: 10, multiHealTriggerCount: 4, multiHealTargets: 3, multiHealDuration: 4000, multiHealAmount: 5},
            'alchemist':   { name: 'Alchemist',   tags: ['Ranged', 'Support'], hp: 85, speed: 0.7, attackDamage: 5,    attackRange: 320,  attackCooldown: 2200, color: { team1: '#4ade80', team2: '#ca8a04' }, poisonDuration: 5000, dps: 5, poisonAoeRadius: 40, specialTriggerCount: 2, antiHealTargets: 3, healReductionAmount: 0.97, healReductionDuration: 8000 },
            'sledgehammer':{ name: 'Sledgehammer',tags: ['Melee', 'Tank'],   hp: 160, speed: 0.5,  attackDamage: 30,   attackRange: 45,   attackCooldown: 2800, color: { team1: '#60a5fa', team2: '#f87171' }, critMultiplier: 2.5, critTargets: ['guardian', 'rockgolem'] },
            'duelist':     { name: 'Duelist',     tags: ['Melee'],           hp: 90,  speed: 1.1,  attackDamage: 12,   attackRange: 40,   attackCooldown: 680,  color: { team1: '#60a5fa', team2: '#f87171' }, burstTriggerCount: 3, burstSlashCount: 3, burstSlashCooldown: 120 },
            'rockgolem':   { name: 'Rock Golem',  tags: ['Tank', 'Melee'],   hp: 360, speed: 0.3,  attackDamage: 8,    attackRange: 50,   attackCooldown: 4500, color: { team1: '#60a5fa', team2: '#f87171' }, aoeRadius: 100, aoeDamage: 10, stunDuration: 850, size: 28 },
            'troll':       { name: 'Troll',       tags: ['Melee', 'Tank'],   hp: 250, speed: 0.35, attackDamage: 55,   attackRange: 60,   attackCooldown: 3500, color: { team1: '#166534', team2: '#78350f' }, size: 35, alwaysCrit: true, smashTriggerCount: 3, smashAoeRadius: 120, smashStunDuration: 1500, smashKnockback: 120, smashSlowDuration: 3000, smashSlowAmount: 0.5 },
        };

        let selectedUnit = null;
        let units = [];
        let allUnitsThisRound = [];
        let projectiles = [];
        let animations = [];
        let particles = [];
        let isBattleStarted = false;
        let isPaused = false;
        let gameSpeed = 1.0;
        let showRangePreview = false;
        let isRemoveModeActive = false;
        let isInspectModeActive = false;
        let trackedUnit = null;
        let unitToHighlight = null;
        let mousePos = { x: -1, y: -1, onCanvas: false };
        let nextUnitId = 0;
        let initialUnitPlacement = [];
        
        let statsFilter = 'all';
        let isSummarizedView = false;
        let statsUpdateCounter = 0;
        const STATS_UPDATE_INTERVAL = 15;


        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            units.forEach(unit => {
                unit.x = unit.relX * canvas.width;
                unit.y = unit.relY * canvas.height;
            });
        }

        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function drawLightningBolt(startX, startY, endX, endY, segments) {
            const dx = endX - startX;
            const dy = endY - startY;
            const length = Math.sqrt(dx * dx, dy * dy);
            const angle = Math.atan2(dy, dx);
            const segmentLength = length / segments;

            ctx.beginPath();
            ctx.moveTo(startX, startY);

            for (let i = 1; i < segments; i++) {
                const pos = i * segmentLength;
                const offsetX = Math.cos(angle) * pos;
                const offsetY = Math.sin(angle) * pos;
                
                const perpendicularAngle = angle + Math.PI / 2;
                const randomOffset = (Math.random() - 0.5) * 20 * (1 - Math.abs(i - segments/2) / (segments/2));

                const pointX = startX + offsetX + Math.cos(perpendicularAngle) * randomOffset;
                const pointY = startY + offsetY + Math.sin(perpendicularAngle) * randomOffset;
                
                ctx.lineTo(pointX, pointY);
            }
            ctx.lineTo(endX, endY);
        }
        
        class Unit {
            constructor(x, y, team, type, relX, relY) {
                this.id = nextUnitId++;
                this.x = x; this.y = y;
                this.relX = relX; this.relY = relY;
                this.team = team; this.type = type;
                const specs = UNIT_SPECS[type];
                this.hp = specs.hp; this.maxHp = specs.hp;
                this.speed = specs.speed;
                this.attackDamage = specs.attackDamage;
                this.attackRange = specs.attackRange;
                this.attackCooldown = specs.attackCooldown;
                this.color = specs.color[team === 1 ? 'team1' : 'team2'];
                this.lastAttackTime = 0;
                this.target = null;
                this.width = specs.size || 20; 
                this.height = specs.size || 20;

                this.damageDealt = 0;
                this.damageTaken = 0;
                this.healingDone = 0; 
                this.kills = 0;

                this.armor = 0;
                this.coldStacks = 0;

                this.isBeingKnockedBack = false;
                this.knockbackTargetX = 0;
                this.knockbackTargetY = 0;
                
                this.isSlashing = false;
                this.slashAnimDuration = 15;
                this.slashAnimProgress = 0;
                this.deflectAnim = 0;
                
                this.isThrusting = false;
                this.thrustAnimDuration = 20;
                this.thrustAnimProgress = 0;

                this.isThrowing = false;
                this.throwAnimDuration = 30;
                this.throwAnimProgress = 0;
                
                this.isSmashing = false;
                this.smashAnimDuration = 40;
                this.smashAnimProgress = 0;

                this.isSwinging = false;
                this.swingAnimDuration = 50;
                this.swingAnimProgress = 0;

                this.basicAttackCounter = 0;
                this.isBursting = false;
                this.burstsLeft = 0;
                this.lastBurstSlashTime = 0;
                this.activeSword = 1;

                this.healAttackCounter = 0;
                this.isMultiHealActive = false;
                this.multiHealEndTime = 0;

                this.isCasting = false;
                this.castAnimProgress = 0;
                this.glowAnimProgress = Math.random() * Math.PI * 2;

                this.buffs = {};
                this.stunnedUntil = 0;
                this.stunType = null; // Can be 'stun', 'freeze' etc.
            }

            draw() {
                ctx.save();

                // Freeze effect - content drawn BEFORE unit
                if (this.stunType === 'freeze' && Date.now() < this.stunnedUntil) {
                    ctx.save();
                    const size = this.width * 0.8;
                    ctx.fillStyle = 'rgba(165, 243, 252, 0.6)';
                    ctx.strokeStyle = 'rgba(224, 242, 254, 0.8)';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.moveTo(this.x - size, this.y - size);
                    ctx.lineTo(this.x + size, this.y - size);
                    ctx.lineTo(this.x + size * 0.8, this.y);
                    ctx.lineTo(this.x + size, this.y + size);
                    ctx.lineTo(this.x - size, this.y + size);
                    ctx.lineTo(this.x - size * 0.7, this.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();

                    ctx.filter = 'saturate(0.3) brightness(1.5)';
                }

                ctx.fillStyle = this.color;

                if (this.type === 'druid' || this.type === 'cryomancer') {
                    const glowSize = Math.sin(this.glowAnimProgress) * 5 + 20;
                    ctx.globalCompositeOperation = 'lighter';
                     if (this.type === 'cryomancer') {
                         ctx.fillStyle = this.team === 1 ? 'rgba(165, 243, 252, 0.4)' : 'rgba(103, 232, 249, 0.4)';
                     } else {
                         ctx.fillStyle = this.team === 1 ? 'rgba(74, 222, 128, 0.4)' : 'rgba(163, 230, 53, 0.4)';
                     }
                    ctx.filter = 'blur(10px)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore(); // Restore context for drawing the unit itself
                    ctx.save();   // And save it again for potential freeze effect
                    if (this.stunType === 'freeze' && Date.now() < this.stunnedUntil) {
                       ctx.filter = 'saturate(0.3) brightness(1.5)';
                    }
                    ctx.fillStyle = this.color;
                }

                if (this.buffs.druidHeal) {
                    const glowSize = 18;
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = this.team === 1 ? 'rgba(74, 222, 128, 0.5)' : 'rgba(163, 230, 53, 0.5)';
                    ctx.filter = 'blur(8px)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width / 2 + 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.type === 'rockgolem' || this.type === 'troll') {
                    ctx.beginPath();
                    ctx.rect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore(); // Restore after unit and potential freeze effect

                this.drawEquipment();
                
                ctx.fillStyle = this.team === 1 ? 'rgba(100, 200, 255, 0.7)' : 'rgba(255, 100, 100, 0.7)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width / 2 + 3, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = ctx.fillStyle;
                ctx.stroke();
                
                // --- HEALTH BAR AND BUFF BARS ---
                const barWidth = 30;
                let barY = this.y - this.height - 15;

                if (this.buffs.armor && this.buffs.armor.expires > Date.now()) {
                    const barHeight = 3;
                    const timeRemaining = this.buffs.armor.expires - Date.now();
                    const progress = Math.max(0, timeRemaining / this.buffs.armor.duration);

                    ctx.fillStyle = 'rgba(75, 85, 99, 0.5)'; 
                    ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                    ctx.fillStyle = '#67e8f9';
                    ctx.fillRect(this.x - barWidth / 2, barY, barWidth * progress, barHeight);
                    barY += barHeight + 1;
                }

                if (this.buffs.healingReduced && this.buffs.healingReduced.expires > Date.now()) {
                    const barHeight = 3;
                    const timeRemaining = this.buffs.healingReduced.expires - Date.now();
                    const progress = Math.max(0, timeRemaining / this.buffs.healingReduced.duration);

                    ctx.fillStyle = 'rgba(75, 85, 99, 0.5)';
                    ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
                    ctx.fillStyle = '#d946ef'; // fuchsia for heal reduction
                    ctx.fillRect(this.x - barWidth / 2, barY, barWidth * progress, barHeight);
                    barY += barHeight + 1;
                }
                
                // Health + Armor Bar
                const healthBarHeight = 5;
                const healthBarX = this.x - barWidth / 2;
                const healthBarY = barY;

                ctx.fillStyle = '#4b5563'; // Background
                ctx.fillRect(healthBarX, healthBarY, barWidth, healthBarHeight);

                const healthWidth = (this.hp / this.maxHp) * barWidth;
                const armorWidth = (this.armor / this.maxHp) * barWidth;

                const healthColor = this.hp / this.maxHp > 0.5 ? '#22c55e' : this.hp / this.maxHp > 0.25 ? '#f59e0b' : '#ef4444';
                ctx.fillStyle = healthColor;
                ctx.fillRect(healthBarX, healthBarY, healthWidth, healthBarHeight);
                
                ctx.fillStyle = 'rgba(103, 232, 249, 0.8)'; // Lighter, semi-transparent cyan for armor overlay
                ctx.fillRect(healthBarX + healthWidth, healthBarY, Math.min(armorWidth, barWidth - healthWidth), healthBarHeight);

                // Cooldown Bar
                let specialBarY = healthBarY + healthBarHeight + 1;
                if (isBattleStarted && this.attackCooldown > 0) {
                    const cooldownBarHeight = 3;
                    
                    ctx.fillStyle = 'rgba(75, 85, 99, 0.5)';
                    ctx.fillRect(healthBarX, specialBarY, barWidth, cooldownBarHeight);

                    let currentCooldown = this.attackCooldown;
                    if (this.buffs.bard && Date.now() < this.buffs.bard.expires) {
                        currentCooldown /= (1 + this.buffs.bard.attackSpeedBoost);
                    }
                    const cooldownProgress = Math.min(1, (Date.now() - this.lastAttackTime) / (currentCooldown / gameSpeed));
                    
                    ctx.fillStyle = '#facc15';
                    ctx.fillRect(healthBarX, specialBarY, cooldownProgress * barWidth, cooldownBarHeight);
                    specialBarY += cooldownBarHeight + 1;
                }
                
                // Special Ability Counter Bars
                const specialBarHeight = 4;
                if ((this.type === 'duelist' || this.type === 'druid' || this.type === 'priest' || this.type === 'troll' || this.type === 'cryomancer' || this.type === 'alchemist') && isBattleStarted) {
                    ctx.fillStyle = 'rgba(75, 85, 99, 0.5)';
                    ctx.fillRect(healthBarX, specialBarY, barWidth, specialBarHeight);
                    
                    let specs, counter, maxCount, barColor, activeColor, activeDuration, activeEndTime;
                    
                    switch(this.type) {
                        case 'duelist':
                            specs = UNIT_SPECS.duelist;
                            counter = this.basicAttackCounter; maxCount = specs.burstTriggerCount;
                            barColor = '#a78bfa';
                            break;
                        case 'druid':
                            specs = UNIT_SPECS.druid;
                            counter = this.healAttackCounter; maxCount = specs.multiHealTriggerCount;
                            barColor = '#4ade80';
                            activeColor = '#16a34a'; activeDuration = specs.multiHealDuration; activeEndTime = this.multiHealEndTime;
                            break;
                        case 'priest':
                            specs = UNIT_SPECS.priest;
                            counter = this.healAttackCounter; maxCount = specs.lightHealTriggerCount;
                            barColor = '#fef08a';
                            break;
                        case 'troll':
                             specs = UNIT_SPECS.troll;
                             counter = this.basicAttackCounter; maxCount = specs.smashTriggerCount;
                             barColor = '#f97316';
                             break;
                        case 'cryomancer':
                             specs = UNIT_SPECS.cryomancer;
                             counter = this.basicAttackCounter; maxCount = specs.specialTriggerCount;
                             barColor = '#67e8f9';
                             break;
                        case 'alchemist':
                             specs = UNIT_SPECS.alchemist;
                             counter = this.basicAttackCounter; maxCount = specs.specialTriggerCount;
                             barColor = '#bef264';
                             break;
                    }

                    if (this.isMultiHealActive) { // Druid specific active state
                         const progress = (activeEndTime - Date.now()) / activeDuration;
                         ctx.fillStyle = activeColor;
                         ctx.fillRect(healthBarX, specialBarY, barWidth * progress, specialBarHeight);
                    } else if (counter > 0) {
                        const segmentWidth = barWidth / maxCount;
                        ctx.fillStyle = barColor;
                        for (let i = 0; i < counter; i++) {
                            ctx.fillRect(healthBarX + i * segmentWidth, specialBarY, segmentWidth - 1, specialBarHeight);
                        }
                    }
                }

                // Buff Icons
                let iconX = this.x;
                const iconSpacing = 12;
                if (this.buffs.bard && Date.now() < this.buffs.bard.expires) {
                    ctx.fillStyle = '#f0abfc'; ctx.font = 'bold 18px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText('', iconX, healthBarY - 2);
                    iconX -= iconSpacing;
                }
                if (this.buffs.druidHeal) {
                    ctx.fillStyle = '#4ade80'; ctx.font = 'bold 18px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText('+', iconX, healthBarY - 2);
                    iconX -= iconSpacing;
                }
                 if (this.buffs.armor && Date.now() < this.buffs.armor.expires) {
                    ctx.fillStyle = '#67e8f9'; ctx.font = 'bold 16px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText('', iconX, healthBarY - 2);
                    iconX -= iconSpacing;
                }
                if (this.buffs.healingReduced && Date.now() < this.buffs.healingReduced.expires) {
                    ctx.fillStyle = '#d946ef'; ctx.font = 'bold 16px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText('', this.x, healthBarY - 15);
                }
                 if (this.buffs.poison && Date.now() < this.buffs.poison.expires) {
                    ctx.fillStyle = '#84cc16'; ctx.font = 'bold 16px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText('', this.x + iconSpacing, healthBarY - 15);
                }
                if (this.coldStacks > 0) {
                    ctx.fillStyle = '#38bdf8'; ctx.font = 'bold 16px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText(`${this.coldStacks}`, this.x - iconSpacing, healthBarY - 15);
                }
                if (Date.now() < this.stunnedUntil) {
                    ctx.fillStyle = 'white'; ctx.font = 'bold 12px "Roboto Mono"';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText(this.stunType === 'freeze' ? 'FROZEN' : 'STUN', this.x, healthBarY - 2);

                    const angle = (Date.now() / 200) % (Math.PI * 2);
                    ctx.fillStyle = '#facc15'; ctx.font = 'bold 14px "Roboto Mono"';
                    for (let i = 0; i < 2; i++) {
                        const starAngle = angle + (i * Math.PI);
                        const starX = this.x + Math.cos(starAngle) * 12;
                        const starY = this.y - 25 + Math.sin(starAngle) * 4;
                        ctx.fillText('', starX, starY);
                    }
                }
            }
            
            drawEquipment() {
                let angle = this.team === 1 ? 0 : Math.PI;
                if (this.target) {
                    angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                }

                if (this.type === 'musketeer') {
                    const nozzleLength = 12;
                    const nozzleWidth = 5;
                    const startX = this.x + Math.cos(angle) * (this.width / 2);
                    const startY = this.y + Math.sin(angle) * (this.width / 2);
                    const endX = this.x + Math.cos(angle) * (this.width / 2 + nozzleLength);
                    const endY = this.y + Math.sin(angle) * (this.width / 2 + nozzleLength);
                    ctx.strokeStyle = '#9ca3af';
                    ctx.lineWidth = nozzleWidth;
                    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
                } else if (this.type === 'archer') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    const bowHeight = 30;
                    ctx.strokeStyle = '#854d0e';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, bowHeight / 2, -Math.PI/2.5, Math.PI/2.5, false);
                    ctx.stroke();
                    ctx.strokeStyle = '#e5e7eb';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -bowHeight / 2.2);
                    ctx.lineTo(0, bowHeight / 2.2);
                    ctx.stroke();
                    ctx.restore();
                } else if (this.type === 'swordsman') {
                    let swordAngle = angle;
                    if (this.isSlashing) {
                        const progress = this.slashAnimProgress / this.slashAnimDuration;
                        const arc = Math.PI / 1.5;
                        swordAngle += (1 - progress) * arc - (arc / 2); 
                    }
                    const swordLength = 18; const swordWidth = 4;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(swordAngle);
                    const hiltPosition = this.width / 2 - 8;
                    ctx.fillStyle = '#d1d5db';
                    ctx.fillRect(hiltPosition, -swordWidth / 2, swordLength, swordWidth);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(hiltPosition, -swordWidth, swordWidth, swordWidth * 2);
                    ctx.restore();
                } else if (this.type === 'spearman') {
                    const spearLength = 35; const spearWidth = 3;
                    const headLength = 8; const headWidth = 6;
                    let thrustOffset = 0;
                    if (this.isThrusting) {
                        const progress = this.thrustAnimProgress / this.thrustAnimDuration;
                        thrustOffset = Math.sin(progress * Math.PI) * 15;
                    }
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(angle);
                    const shaftStart = this.width / 2 - 10 + thrustOffset;
                    ctx.fillStyle = '#a16207';
                    ctx.fillRect(shaftStart, -spearWidth / 2, spearLength, spearWidth);
                    ctx.fillStyle = '#a8a29e';
                    ctx.beginPath();
                    ctx.moveTo(shaftStart + spearLength, 0);
                    ctx.lineTo(shaftStart + spearLength - headLength, -headWidth / 2);
                    ctx.lineTo(shaftStart + spearLength - headLength, headWidth / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'guardian') {
                    const shieldWidth = 10; const shieldHeight = 30;
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(angle);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(this.width / 2, -shieldHeight / 2, shieldWidth, shieldHeight);
                    if (this.deflectAnim > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.deflectAnim / 10})`;
                        ctx.fillRect(this.width / 2, -shieldHeight / 2, shieldWidth, shieldHeight);
                    }
                    ctx.restore();
                    let swordAngle = angle;
                    if (this.isSlashing) {
                        const progress = this.slashAnimProgress / this.slashAnimDuration;
                        const arc = Math.PI / 1.5;
                        swordAngle += (1 - progress) * arc - (arc / 2);
                    }
                    const swordLength = 18; const swordWidth = 4;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(swordAngle);
                    const hiltPosition = this.width / 2 - 8;
                    ctx.fillStyle = '#d1d5db';
                    ctx.fillRect(hiltPosition, -swordWidth / 2, swordLength, swordWidth);
                    ctx.fillStyle = '#9ca3af';
                    ctx.fillRect(hiltPosition, -swordWidth, swordWidth, swordWidth * 2);
                    ctx.restore();
                } else if (this.type === 'priest') {
                    const crossVLength = 24, crossHLength = 16;
                    const crossWidth = 5;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.fillStyle = '#fde047'; // Gold color
                    ctx.shadowColor = '#fef08a';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(this.width / 2, -crossVLength / 2, crossWidth, crossVLength);
                    ctx.fillRect(this.width / 2 - (crossHLength - crossWidth)/2, -crossVLength/2 + 4, crossHLength, crossWidth);
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'alchemist') {
                    let throwProgress = 0;
                    if (this.isThrowing) {
                        throwProgress = this.throwAnimProgress / this.throwAnimDuration;
                    }
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle + (Math.sin(throwProgress * Math.PI) * -Math.PI / 2)); // Wind up and throw motion

                    const flaskBodyWidth = 10;
                    const flaskNeckHeight = 4;
                    const flaskNeckWidth = 4;
                    
                    const flaskX = 8;
                    // Liquid
                    ctx.fillStyle = this.team === 1 ? '#a3e635' : '#facc15';
                    ctx.beginPath();
                    ctx.arc(flaskX, 0, flaskBodyWidth/2, 0, Math.PI * 2);
                    ctx.fill();

                    // Glass
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(flaskX, 0, flaskBodyWidth/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(flaskX - flaskNeckWidth/2, -flaskBodyWidth/2 - flaskNeckHeight + 2, flaskNeckWidth, flaskNeckHeight);

                    ctx.restore();
                } else if (this.type === 'flamecaller') {
                    const staffLength = 24; const staffWidth = 4; const gemSize = 6;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#b45309';
                    ctx.fillRect(this.width / 2, -staffWidth / 2, staffLength, staffWidth);
                    let gemColor = (this.team === 1 ? '#f97316' : '#ef4444');
                    ctx.shadowColor = gemColor;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = gemColor;
                    ctx.beginPath();
                    ctx.arc(this.width / 2 + staffLength, 0, gemSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 + staffLength, 0, gemSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'cryomancer') {
                    const gemSize = 8;
                    const floatingDist = this.width / 2 + 5;
                    const floatAngle = Date.now() / 400;

                    const gemX = this.x + Math.cos(angle) * floatingDist + Math.cos(floatAngle) * 3;
                    const gemY = this.y + Math.sin(angle) * floatingDist + Math.sin(floatAngle) * 3;

                    ctx.save();
                    const gemColor = (this.team === 1 ? '#67e8f9' : '#06b6d4');
                    ctx.shadowColor = gemColor;
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = gemColor;

                    ctx.beginPath();
                    ctx.moveTo(gemX, gemY - gemSize);
                    ctx.lineTo(gemX + gemSize * 0.7, gemY);
                    ctx.lineTo(gemX, gemY + gemSize);
                    ctx.lineTo(gemX - gemSize * 0.7, gemY);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(gemX, gemY, gemSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                } else if (this.type === 'druid') {
                    const branchLength = 28;
                    const branchWidth = 4;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;

                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(angle);

                    ctx.strokeStyle = '#5f3f2e';
                    ctx.lineWidth = branchWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.width/2 - 8, 0);
                    ctx.quadraticCurveTo(this.width/2 + branchLength/2, -8, this.width/2 + branchLength, 5);
                    ctx.stroke();

                    ctx.lineWidth = branchWidth * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(this.width/2 + 5, 0);
                    ctx.quadraticCurveTo(this.width/2 + 12, 6, this.width/2 + 18, 8);
                    ctx.stroke();

                    const leafColor = this.team === 1 ? '#4ade80' : '#a3e635';
                    ctx.fillStyle = leafColor;
                    
                    const drawLeaf = (x, y, rotation) => {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(rotation);
                        ctx.scale(1, 0.6);
                        ctx.beginPath();
                        ctx.arc(0, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    };

                    drawLeaf(this.width/2 + branchLength, 5, Math.PI / 4);
                    drawLeaf(this.width/2 + branchLength - 5, -2, -Math.PI / 6);
                    drawLeaf(this.width/2 + 18, 8, Math.PI / 3);
                    
                    ctx.restore();
                }
                 else if (this.type === 'wizard') {
                    let orbSize = 8;
                    const floatingHeight = Math.sin(Date.now() / 300) * 3 - 15;
                     if (this.isCasting) {
                        const progress = 1 - (this.castAnimProgress / 30);
                        orbSize += Math.sin(progress * Math.PI) * 4;
                        if(Math.random() < 0.5) particles.push(new Particle(this.x, this.y + floatingHeight, this.team, false, 'electric'));
                    }
                    ctx.save();
                    ctx.translate(this.x, this.y + floatingHeight);
                    let orbColor = this.team === 1 ? '#a78bfa' : '#fde047';
                    ctx.shadowColor = orbColor;
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = orbColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, orbSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(0, 0, orbSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'bard') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle + Math.PI / 2.5);
                    ctx.strokeStyle = '#854d0e'; // Brown
                    ctx.lineWidth = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(-8, 5);
                    ctx.quadraticCurveTo(-10, -10, 0, -12);
                    ctx.quadraticCurveTo(10, -10, 8, 5);
                    ctx.lineTo(-8, 5);
                    ctx.stroke();

                    ctx.strokeStyle = '#fde047'; // Gold
                    ctx.lineWidth = 1;
                    for (let i = -6; i <= 6; i += 3) {
                        ctx.beginPath();
                        ctx.moveTo(i, 5);
                        ctx.lineTo(i * 0.7, -8);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.type === 'sledgehammer' || this.type === 'troll') {
                    let weaponAngle = angle;
                    const progress = this.swingAnimProgress / this.swingAnimDuration;
                    
                    if (this.isSwinging) {
                        // Raise and slam animation
                        if (progress > 0.5) { 
                            const raiseProgress = (1 - progress) * 2; // from 1 to 0
                            weaponAngle -= raiseProgress * (Math.PI / 1.5);
                        } else {
                            const slamProgress = progress * 2; // from 0 to 1
                            weaponAngle += slamProgress * Math.PI;
                        }
                    }

                    const handleLength = this.type === 'troll' ? 30 : 22;
                    const handleWidth = this.type === 'troll' ? 6 : 4;
                    const headWidth = this.type === 'troll' ? 20 : 12;
                    const headHeight = this.type === 'troll' ? 18 : 10;
                    const offsetDistance = 8;
                    const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                    const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                    
                    ctx.save();
                    ctx.translate(this.x + offsetX, this.y + offsetY);
                    ctx.rotate(weaponAngle);
                    
                    const handleStart = this.width / 2 - 10;
                    ctx.fillStyle = '#a16207'; // Brown for handle
                    ctx.fillRect(handleStart, -handleWidth / 2, handleLength, handleWidth);
                    
                    ctx.fillStyle = this.type === 'troll' ? '#78716c' : '#a8a29e'; // Darker gray for troll
                    const headX = handleStart + handleLength;
                    ctx.fillRect(headX, -headHeight / 2, headWidth, headHeight);

                    ctx.restore();
                } else if (this.type === 'duelist') {
                    for (let i = -1; i <= 1; i += 2) {
                        let swordAngle = angle;
                        if (this.isSlashing && this.activeSword === i) {
                            const progress = this.slashAnimProgress / this.slashAnimDuration;
                            const arc = Math.PI / 1.5;
                            swordAngle += (1 - progress) * arc - (arc / 2);
                        }
                        const swordLength = 18; const swordWidth = 4;
                        const offsetDistance = 8 * i;
                        const offsetX = Math.cos(angle + Math.PI / 2) * offsetDistance;
                        const offsetY = Math.sin(angle + Math.PI / 2) * offsetDistance;
                        ctx.save();
                        ctx.translate(this.x + offsetX, this.y + offsetY);
                        ctx.rotate(swordAngle);
                        const hiltPosition = this.width / 2 - 8;
                        ctx.fillStyle = '#d1d5db';
                        ctx.fillRect(hiltPosition, -swordWidth / 2, swordLength, swordWidth);
                        ctx.fillStyle = '#9ca3af';
                        ctx.fillRect(hiltPosition, -swordWidth, swordWidth, swordWidth * 2);
                        ctx.restore();
                    }
                } else if (this.type === 'rockgolem') {
                    for (let i = -1; i <= 1; i += 2) {
                        let armAngle = angle + (i * Math.PI / 4);
                        let armDist = this.width / 2;

                        if (this.isSmashing) {
                            const progress = this.smashAnimProgress / this.smashAnimDuration;
                            if (progress > 0.5) {
                                const raiseProgress = (1 - progress) * 2;
                                armAngle -= (i * (Math.PI / 2) * raiseProgress);
                                armDist += 5 * raiseProgress;
                            } else {
                                const smashProgress = progress * 2;
                                armAngle += (i * (Math.PI/2.2) * smashProgress);
                                armDist += 10 * Math.sin(smashProgress * Math.PI);
                            }
                        }

                        const fistX = this.x + Math.cos(armAngle) * armDist;
                        const fistY = this.y + Math.sin(armAngle) * armDist;
                        
                        ctx.fillStyle = '#a1a1aa';
                        ctx.beginPath();
                        ctx.arc(fistX, fistY, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#4b5563';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }

            findTarget(enemies) {
                if (enemies.length === 0) { this.target = null; return; }
                let closestEnemy = null;
                let minDistance = Infinity;
                enemies.forEach(e => {
                    const d = getDistance(this, e);
                    if (d < minDistance) { minDistance = d; closestEnemy = e; }
                });
                this.target = closestEnemy;
            }
             findAllyTarget(friendlies) {
                const alliesToHeal = friendlies.filter(f => f.hp < f.maxHp && f !== this);
                if (alliesToHeal.length === 0) { this.target = null; return; }

                alliesToHeal.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.hp));
                this.target = alliesToHeal[0];
            }
            
            applySeparation(friendlies) {
                if (this.type === 'guardian') return;
                let steerX = 0, steerY = 0;
                friendlies.forEach(other => {
                    if (other !== this && other.type !== 'guardian') {
                        const d = getDistance(this, other);
                        if (d > 0 && d < this.width * 1.5) {
                            const diffX = this.x - other.x; const diffY = this.y - other.y;
                            steerX += diffX / d; steerY += diffY / d;
                        }
                    }
                });
                this.x += steerX * 0.5 * gameSpeed; this.y += steerY * 0.5 * gameSpeed;
            }

            update(friendlies, enemies) {
                if (this.isBeingKnockedBack) {
                    this.x += (this.knockbackTargetX - this.x) * 0.1 * gameSpeed;
                    this.y += (this.knockbackTargetY - this.y) * 0.1 * gameSpeed;
                    if (getDistance(this, {x: this.knockbackTargetX, y: this.knockbackTargetY}) < 5) {
                        this.isBeingKnockedBack = false;
                    }
                }

                for (const buffKey in this.buffs) {
                    if (Date.now() > this.buffs[buffKey].expires) {
                        if (buffKey === 'armor') this.armor = 0;
                        if (buffKey === 'chilled') this.coldStacks = 0;
                        delete this.buffs[buffKey];
                    }
                }
                 
                if (this.buffs.druidHeal) {
                    let healAmount = this.buffs.druidHeal.healPerTick * gameSpeed;
                     if(this.buffs.healingReduced) {
                        healAmount *= (1 - this.buffs.healingReduced.amount);
                    }
                    this.hp = Math.min(this.maxHp, this.hp + healAmount);
                    this.buffs.druidHeal.caster.healingDone += healAmount;
                    this.buffs.druidHeal.healedSinceLastText += healAmount;
                    if(Date.now() > this.buffs.druidHeal.nextTextTime) {
                        if (this.buffs.druidHeal.healedSinceLastText >= 1) {
                            animations.push(new FloatingText(`+${Math.round(this.buffs.druidHeal.healedSinceLastText)}`, this.x, this.y, '#4ade80'));
                            this.buffs.druidHeal.healedSinceLastText = 0;
                            this.buffs.druidHeal.nextTextTime = Date.now() + 1000;
                        }
                    }
                }
                
                if (this.buffs.poison && Date.now() < this.buffs.poison.expires) {
                    const damage = this.buffs.poison.dps * (1000/60 / 1000) * gameSpeed; // damage per frame
                    const actualDamage = Math.min(this.hp, damage);
                    this.hp -= actualDamage;
                    this.damageTaken += actualDamage;
                    if (this.buffs.poison.caster) {
                        this.buffs.poison.caster.damageDealt += actualDamage;
                    }
                    if (this.hp <= 0 && this.buffs.poison.caster && !this.buffs.poison.killAwarded) {
                        this.buffs.poison.caster.kills++;
                        this.buffs.poison.killAwarded = true;
                    }
                    if(Math.random() < 0.2) {
                        particles.push(new Particle(this.x, this.y, this.team === 1 ? 2 : 1, false, 'poison'));
                    }
                }

                if (Date.now() < this.stunnedUntil || this.isBeingKnockedBack) return;
                if(this.isCasting) { this.castAnimProgress -= 1 * gameSpeed; if(this.castAnimProgress <= 0) this.isCasting = false; }
                this.glowAnimProgress += 0.05 * gameSpeed;
                if (this.isSlashing) { this.slashAnimProgress -= 1 * gameSpeed; if (this.slashAnimProgress <= 0) this.isSlashing = false; }
                if (this.isThrusting) { this.thrustAnimProgress -= 1 * gameSpeed; if (this.thrustAnimProgress <= 0) this.isThrusting = false; }
                if (this.isThrowing) { this.throwAnimProgress -= 1 * gameSpeed; if (this.throwAnimProgress <= 0) this.isThrowing = false; }
                if (this.deflectAnim > 0) this.deflectAnim -= 1 * gameSpeed;
                if (this.isSmashing) { this.smashAnimProgress -= 1 * gameSpeed; if (this.smashAnimProgress <= 0) this.isSmashing = false; }
                if (this.isSwinging) { this.swingAnimProgress -= 1 * gameSpeed; if (this.swingAnimProgress <= 0) this.isSwinging = false; }
                if (this.isMultiHealActive && Date.now() > this.multiHealEndTime) this.isMultiHealActive = false;

                let currentSpeed = this.speed;
                if (this.buffs.slow && Date.now() < this.buffs.slow.expires) {
                    currentSpeed *= (1 - this.buffs.slow.amount);
                }

                if (this.type === 'druid' || this.type === 'priest' || this.type === 'bard') {
                    if (this.type === 'druid') {
                        this.findAllyTarget(friendlies.filter(f => getDistance(this, f) <= this.attackRange));
                        if(this.target) {
                           this.attack(friendlies);
                           return; // If healing, stay put
                        }
                    }
                   
                    if (friendlies.length > 1) {
                        let totalX = 0, totalY = 0;
                        let frontmostX = this.team === 1 ? -Infinity : Infinity;
                        friendlies.forEach(f => {
                            if (f !== this) {
                                totalX += f.x; totalY += f.y;
                                if (this.team === 1) frontmostX = Math.max(frontmostX, f.x);
                                else frontmostX = Math.min(frontmostX, f.x);
                            }
                        });
                        const avgY = totalY / (friendlies.length - 1);
                        const followDistance = this.type === 'priest' ? 120 : 100;
                        const targetX = this.team === 1 ? frontmostX - followDistance : frontmostX + followDistance;
                        const dist = getDistance(this, {x: targetX, y: avgY});
                        if(dist > 30) {
                            const angle = Math.atan2(avgY - this.y, targetX - this.x);
                            this.x += Math.cos(angle) * currentSpeed * gameSpeed;
                            this.y += Math.sin(angle) * currentSpeed * gameSpeed;
                        }
                    }
                    this.attack(enemies); 
                    return;
                }
                
                // Melee and Ranged unit logic
                this.applySeparation(friendlies);
                this.findTarget(enemies);
                if (this.target) {
                    if (getDistance(this, this.target) > this.attackRange) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        this.x += Math.cos(angle) * currentSpeed * gameSpeed;
                        this.y += Math.sin(angle) * currentSpeed * gameSpeed;
                    } else {
                        this.attack(enemies);
                    }
                } else {
                    this.x += (this.team === 1 ? currentSpeed : -currentSpeed) * gameSpeed;
                }

                const radius = this.width / 2;
                this.x = Math.max(radius, Math.min(this.x, canvas.width - radius));
                this.y = Math.max(radius, Math.min(this.y, canvas.height - radius));
                this.relX = this.x / canvas.width; this.relY = this.y / canvas.height;
            }
            
            attack(alliesOrEnemies) {
                let currentCooldown = this.attackCooldown;
                if (this.buffs.bard && Date.now() < this.buffs.bard.expires) {
                    currentCooldown /= (1 + this.buffs.bard.attackSpeedBoost);
                }
                const now = Date.now();

                if (this.type === 'duelist') {
                    const specs = UNIT_SPECS.duelist;
                    if (this.isBursting) {
                        if (now - this.lastBurstSlashTime > specs.burstSlashCooldown / gameSpeed) {
                            this.lastBurstSlashTime = now;
                            this.burstsLeft--;
                            this.activeSword *= -1;
                            if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                                this.target.takeDamage(this.attackDamage, this);
                                animations.push(new SlashAnimation(this));
                                this.isSlashing = true; this.slashAnimProgress = this.slashAnimDuration;
                            }
                            if (this.burstsLeft <= 0) {
                                this.isBursting = false;
                                this.lastAttackTime = now;
                            }
                        }
                    } else if (now - this.lastAttackTime > currentCooldown / gameSpeed) {
                        this.lastAttackTime = now;
                        this.basicAttackCounter++;

                        if (this.basicAttackCounter >= specs.burstTriggerCount) {
                            this.basicAttackCounter = 0;
                            this.isBursting = true;
                            this.burstsLeft = specs.burstSlashCount;
                            this.lastBurstSlashTime = now - (specs.burstSlashCooldown / gameSpeed); 
                        } else {
                            this.activeSword *= -1;
                            if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                                this.target.takeDamage(this.attackDamage, this);
                                animations.push(new SlashAnimation(this));
                                this.isSlashing = true; this.slashAnimProgress = this.slashAnimDuration;
                            }
                        }
                    }
                    return;
                }
                
                if (now - this.lastAttackTime > currentCooldown / gameSpeed) {
                    this.lastAttackTime = now;

                    if (this.type === 'wizard') {
                        if(this.target) {
                            this.isCasting = true;
                            this.castAnimProgress = 30;
                            animations.push(new ChainLightning(this, this.target, units));
                        }
                        return;
                    }
                    if (this.type === 'druid') {
                        const specs = UNIT_SPECS.druid;
                        if (this.isMultiHealActive) return;

                        if (this.healAttackCounter >= specs.multiHealTriggerCount - 1) {
                            this.healAttackCounter = 0;
                            this.isMultiHealActive = true;
                            this.multiHealEndTime = now + specs.multiHealDuration;
                            animations.push(new MultiHealAura(this, units));
                        } else {
                            if (this.target) {
                                projectiles.push(new HealingOrb(this, this.target));
                                this.healAttackCounter++;
                            }
                        }
                        return;
                    }
                     if (this.type === 'priest') {
                        const specs = UNIT_SPECS.priest;
                        this.healAttackCounter++;

                        if (this.healAttackCounter >= specs.lightHealTriggerCount) {
                            this.healAttackCounter = 0;
                            animations.push(new AoeHeal(this.x, this.y, specs.healRadius, specs.healAmount, this.team, units, this, specs.lightHealArmorBonus, specs.lightHealArmorDuration, true));
                        } else {
                            animations.push(new AoeHeal(this.x, this.y, specs.healRadius, specs.healAmount, this.team, units, this, 0, 0, false));
                        }
                        return;
                    }
                    if(this.type === 'cryomancer') {
                        const specs = UNIT_SPECS.cryomancer;
                        this.basicAttackCounter++;
                        if (this.basicAttackCounter >= specs.specialTriggerCount) {
                            this.basicAttackCounter = 0;
                            animations.push(new ShiverWaveAnimation(this, units, specs.waveDamage, specs.freezeStacksApplied));
                        } else {
                            if(this.target) projectiles.push(new IceShard(this, this.target));
                        }
                        return;
                    }
                    if (this.type === 'alchemist') {
                        const specs = UNIT_SPECS.alchemist;
                        this.isThrowing = true;
                        this.throwAnimProgress = this.throwAnimDuration;
                        
                        this.basicAttackCounter++;
                        if (this.basicAttackCounter > specs.specialTriggerCount) {
                            this.basicAttackCounter = 0;
                            const enemies = alliesOrEnemies.sort((a,b) => getDistance(this, a) - getDistance(this, b));
                            for(let i = 0; i < Math.min(specs.antiHealTargets, enemies.length); i++) {
                                projectiles.push(new AntiHealDart(this, enemies[i]));
                            }
                        } else {
                            if (this.target) {
                                projectiles.push(new PoisonPotion(this, this.target));
                            }
                        }
                        return;
                    }
                    if (this.type === 'rockgolem') {
                         if (this.target && getDistance(this, this.target) <= this.attackRange + 10) {
                             this.target.takeDamage(this.attackDamage, this);
                             const specs = UNIT_SPECS.rockgolem;
                             animations.push(new GroundSmashAnimation(this, specs.aoeRadius, specs.aoeDamage, specs.stunDuration, units));
                         }
                         return;
                    } else if (this.type === 'bard') {
                        const specs = UNIT_SPECS.bard;
                        animations.push(new AuraBuffAnimation(this, specs.buffRadius, specs.damageBoost, specs.attackSpeedBoost, specs.buffDuration, units));
                        return;
                    }
                    else if (this.type === 'troll') {
                        const specs = UNIT_SPECS.troll;
                        this.basicAttackCounter++;
                        this.isSwinging = true; 
                        this.swingAnimProgress = this.swingAnimDuration;
                        if (this.basicAttackCounter >= specs.smashTriggerCount) {
                            this.basicAttackCounter = 0;
                            animations.push(new TrollSmashAnimation(this, specs.smashAoeRadius, this.attackDamage, specs.smashStunDuration, specs.smashKnockback, units));
                        } else {
                             if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                                this.target.takeDamage(this.attackDamage, this, true); // Always crit/ignore armor
                                for(let i = 0; i < 5; i++) {
                                    particles.push(new Particle(this.target.x, this.target.y, this.team, true, 'rock'));
                                }
                            }
                        }
                        return;
                    }

                    if (this.type === 'musketeer') {
                        projectiles.push(new Projectile(this, this.target, this.attackDamage, this.team));
                    } else if (this.type === 'archer') {
                        projectiles.push(new Arrow(this, this.target));
                    } else if (this.type === 'flamecaller') {
                        projectiles.push(new Fireball(this, this.target));
                    } else if (this.type === 'sledgehammer') {
                        if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                            this.target.takeDamage(this.attackDamage, this);
                             for(let i = 0; i < 5; i++) {
                                particles.push(new Particle(this.target.x, this.target.y, this.team, true, 'rock'));
                            }
                            if (!this.isSwinging) { this.isSwinging = true; this.swingAnimProgress = this.swingAnimDuration; }
                        }
                    } else if (this.type === 'swordsman' || this.type === 'guardian') {
                         if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                            this.target.takeDamage(this.attackDamage, this);
                            animations.push(new SlashAnimation(this));
                            if (!this.isSlashing) { this.isSlashing = true; this.slashAnimProgress = this.slashAnimDuration; }
                         }
                    } else if (this.type === 'spearman') {
                         if (this.target && getDistance(this, this.target) <= this.attackRange + 5) {
                            this.target.takeDamage(this.attackDamage, this);
                            animations.push(new ThrustAnimation(this, this.target));
                            if (!this.isThrusting) { this.isThrusting = true; this.thrustAnimProgress = this.thrustAnimDuration; }
                         }
                    }
                }
            }

            takeDamage(damage, attacker = null, bypassesArmor = false) {
                 let modifiedDamage = damage;
                 const attackerSpecs = attacker ? UNIT_SPECS[attacker.type] : null;

                 if (attacker && attacker.buffs.bard && Date.now() < attacker.buffs.bard.expires) {
                     modifiedDamage *= (1 + attacker.buffs.bard.damageBoost);
                 }
                
                if (attackerSpecs && attackerSpecs.alwaysCrit) {
                     bypassesArmor = true; // Crits also ignore armor
                     animations.push(new FloatingText(`CRIT! ${Math.round(modifiedDamage)}`, this.x, this.y - 20, '#f97316'));
                } else if (attackerSpecs && attackerSpecs.critTargets && attackerSpecs.critTargets.includes(this.type)) {
                    modifiedDamage *= attackerSpecs.critMultiplier;
                    animations.push(new FloatingText(`CRIT! ${Math.round(modifiedDamage)}`, this.x, this.y - 20, '#f97316'));
                }

                let damageToArmor = 0;
                let damageToHp = 0;
                if (this.armor > 0 && !bypassesArmor) {
                    const damageReducedByArmor = modifiedDamage * ARMOR_DAMAGE_REDUCTION_PERCENT;
                    damageToArmor = Math.min(this.armor, damageReducedByArmor);
                    this.armor -= damageToArmor;
                    damageToHp = modifiedDamage - damageToArmor;
                } else {
                    damageToHp = modifiedDamage;
                }

                 const actualDamage = Math.min(this.hp, damageToHp);
                 this.hp -= damageToHp;
                 this.damageTaken += (damageToArmor + actualDamage);
                 if (attacker) {
                     attacker.damageDealt += (damageToArmor + actualDamage);
                 }
                 if (this.hp <= 0 && attacker) {
                     attacker.kills++;
                 }
            }
            deflect() { this.deflectAnim = 10; }
        }
        
        class Projectile {
            constructor(shooter, target, damage, team) {
                this.shooter = shooter;
                this.target = target;
                this.damage = damage;
                this.team = team;
                this.speed = 4;
                this.radius = 4;
                this.angle = Math.atan2(this.target.y - shooter.y, this.target.x - shooter.x);
                const nozzleTipDist = shooter.width / 2 + 8;
                this.x = shooter.x + Math.cos(this.angle) * nozzleTipDist;
                this.y = shooter.y + Math.sin(this.angle) * nozzleTipDist;
            }

            update(enemies) {
                const enemyGuardians = units.filter(u => u.team !== this.team && u.type === 'guardian');
                for (const guardian of enemyGuardians) {
                    const specs = UNIT_SPECS.guardian;
                    if (getDistance(this, guardian) < guardian.width / 2 + 5) {
                        guardian.deflect();
                        if (Math.random() < specs.deflectChance) {
                            this.team = guardian.team;
                            this.target = this.shooter;
                            this.shooter = guardian;
                            return true;
                        } else {
                            guardian.takeDamage(this.damage * 0.5, this.shooter);
                            return false;
                        }
                    }
                }
                if (this.target && this.target.hp > 0) { this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); }
                this.x += Math.cos(this.angle) * this.speed * gameSpeed;
                this.y += Math.sin(this.angle) * this.speed * gameSpeed;
                for (const enemy of enemies) {
                    if (getDistance(this, enemy) < enemy.width / 2 + this.radius) {
                        enemy.takeDamage(this.damage, this.shooter);
                        return false;
                    }
                }
                return (this.x > -this.radius && this.x < canvas.width + this.radius && this.y > -this.radius && this.y < canvas.height + this.radius);
            }
            
            draw() {
                 ctx.fillStyle = this.team === 1 ? '#a7f3d0' : '#fecdd3';
                 ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        class IceShard extends Projectile {
             constructor(shooter, target) {
                const specs = UNIT_SPECS.cryomancer;
                super(shooter, target, specs.attackDamage, shooter.team);
                this.speed = 5;
            }
            
            update(enemies) {
                if(Math.random() < 0.3) {
                    particles.push(new Particle(this.x, this.y, this.team, false, 'ice'));
                }
                return super.update(enemies); // Use base projectile logic for collision
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const length = 12;
                const width = 6;
                const gemColor = this.team === 1 ? '#67e8f9' : '#06b6d4';
                
                ctx.fillStyle = gemColor;
                ctx.beginPath();
                ctx.moveTo(length / 2, 0);
                ctx.lineTo(-length / 2, width / 2);
                ctx.lineTo(-length/2 + 2, 0);
                ctx.lineTo(-length / 2, -width / 2);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        class HealingOrb extends Projectile {
            constructor(shooter, target) {
                const specs = UNIT_SPECS.druid;
                super(shooter, target, 0, shooter.team);
                this.healAmount = specs.healAmount;
                this.speed = 4;
                this.radius = 6;
            }

            update(allies) {
                if (this.target && this.target.hp > 0) { 
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                } else {
                    return false;
                }
                this.x += Math.cos(this.angle) * this.speed * gameSpeed;
                this.y += Math.sin(this.angle) * this.speed * gameSpeed;

                if (getDistance(this, this.target) < this.target.width / 2 + this.radius) {
                    let healedAmount = Math.min(this.target.maxHp - this.target.hp, this.healAmount);
                    if(this.target.buffs.healingReduced) {
                        healedAmount *= (1 - this.target.buffs.healingReduced.amount);
                    }
                    this.target.hp += healedAmount;
                    this.shooter.healingDone += healedAmount;
                    if (healedAmount > 0) {
                        animations.push(new FloatingText(`+${Math.round(healedAmount)}`, this.target.x, this.target.y, '#4ade80'));
                    }
                    for(let i=0; i<8; i++) particles.push(new Particle(this.target.x, this.target.y, this.team, true, 'heal'));
                    return false;
                }
                
                return (this.x > -this.radius && this.x < canvas.width + this.radius && this.y > -this.radius && this.y < canvas.height + this.radius);
            }

            draw() {
                ctx.fillStyle = this.team === 1 ? 'rgba(74, 222, 128, 0.8)' : 'rgba(163, 230, 53, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 255, 0.9)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class Arrow extends Projectile {
            constructor(shooter, target) {
                const specs = UNIT_SPECS.archer;
                super(shooter, target, specs.attackDamage, shooter.team);
                this.speed = 6;
                this.length = 15;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.strokeStyle = this.team === 1 ? '#56c5d6' : '#fca5a5';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.length / 2, 0);
                ctx.lineTo(this.length / 2, 0);
                ctx.stroke();
                ctx.fillStyle = this.team === 1 ? '#eb897f' : '#fecaca';
                ctx.beginPath();
                ctx.moveTo(this.length / 2, 0);
                ctx.lineTo(this.length / 2 - 5, -3);
                ctx.lineTo(this.length / 2 - 5, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        class Fireball extends Projectile {
            constructor(shooter, target) {
                const specs = UNIT_SPECS.flamecaller;
                super(shooter, target, specs.attackDamage, shooter.team);
                this.speed = 3;
                this.radius = 8;
            }

            update(enemies) {
                this.x += Math.cos(this.angle) * this.speed * gameSpeed;
                this.y += Math.sin(this.angle) * this.speed * gameSpeed;
                if(Math.random() > 0.5) { particles.push(new Particle(this.x, this.y, this.team, false, 'fire')); }
                if(this.target && this.target.hp > 0 && getDistance(this, this.target) < this.radius + this.target.width/2) {
                    const specs = UNIT_SPECS.flamecaller;
                    animations.push(new AoeExplosion(this.target.x, this.target.y, specs.aoeRadius, specs.aoeDamage, this.team, units, this.shooter));
                    return false;
                }
                for (const enemy of enemies) {
                    if (getDistance(this, enemy) < enemy.width / 2 + this.radius) {
                        const specs = UNIT_SPECS.flamecaller;
                        animations.push(new AoeExplosion(this.x, this.y, specs.aoeRadius, specs.aoeDamage, this.team, units, this.shooter));
                        return false;
                    }
                }
                return (this.x > -this.radius && this.x < canvas.width + this.radius && this.y > -this.radius && this.y < canvas.height + this.radius);
            }
            
            draw() {
                 ctx.fillStyle = this.team === 1 ? '#fb923c' : '#f87171';
                 ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                 ctx.fillStyle = `rgba(255, 255, 100, 0.8)`;
                 ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2); ctx.fill();
            }
        }

        class PoisonPotion extends Projectile {
            constructor(shooter, target) {
                const specs = UNIT_SPECS.alchemist;
                super(shooter, target, specs.attackDamage, shooter.team);
                this.speed = 3;
                this.rotation = 0;
                this.targetPos = { x: target.x, y: target.y };
            }

            update(enemies) {
                this.rotation += 0.2 * gameSpeed;
                const distToTarget = getDistance(this, this.targetPos);
                
                if (distToTarget < this.speed * gameSpeed) {
                    const specs = UNIT_SPECS.alchemist;
                    animations.push(new PoisonSplashAnimation(this.x, this.y, specs.poisonAoeRadius, this.team, this.shooter));
                    return false; // Remove projectile
                }
                
                const angle = Math.atan2(this.targetPos.y - this.y, this.targetPos.x - this.x);
                this.x += Math.cos(angle) * this.speed * gameSpeed;
                this.y += Math.sin(angle) * this.speed * gameSpeed;

                if (Math.random() < 0.2) {
                    particles.push(new Particle(this.x, this.y, this.team, false, 'poison'));
                }

                return (this.x > -this.radius && this.x < canvas.width + this.radius && this.y > -this.radius && this.y < canvas.height + this.radius);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                const flaskBodyWidth = 10;
                ctx.fillStyle = this.team === 1 ? '#a3e635' : '#facc15';
                ctx.beginPath();
                ctx.arc(0, 0, flaskBodyWidth / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(200, 220, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(0, 0, flaskBodyWidth / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class AntiHealDart extends Projectile {
            constructor(shooter, target) {
                super(shooter, target, 0, shooter.team);
                this.speed = 7;
            }
             update(enemies) {
                if (!this.target || this.target.hp <= 0) return false;

                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speed * gameSpeed;
                this.y += Math.sin(angle) * this.speed * gameSpeed;

                if (getDistance(this, this.target) < this.target.width / 2) {
                    const specs = UNIT_SPECS.alchemist;
                    this.target.buffs.healingReduced = {
                        expires: Date.now() + specs.healReductionDuration,
                        duration: specs.healReductionDuration,
                        amount: specs.healReductionAmount
                    };
                    for(let i = 0; i < 8; i++) {
                        particles.push(new Particle(this.target.x, this.target.y, this.team, true, 'poison'));
                    }
                    return false;
                }
                return (this.x > -this.radius && this.x < canvas.width + this.radius && this.y > -this.radius && this.y < canvas.height + this.radius);
            }
            draw() {
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);
                const length = 10;
                ctx.strokeStyle = '#d946ef';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-length/2, 0);
                ctx.lineTo(length/2, 0);
                ctx.stroke();
                ctx.restore();
            }
        }

        class PoisonSplashAnimation {
             constructor(x, y, radius, team, caster) {
                this.x = x; this.y = y; this.maxRadius = radius; this.team = team; this.caster = caster;
                this.duration = 40; this.maxDuration = 40;
                
                const specs = UNIT_SPECS.alchemist;
                const enemies = units.filter(u => u.team !== this.team);
                enemies.forEach(enemy => {
                    if(getDistance(this, enemy) < this.maxRadius) {
                        enemy.takeDamage(specs.attackDamage, this.caster);
                        enemy.buffs.poison = {
                            expires: Date.now() + specs.poisonDuration,
                            dps: specs.dps,
                            caster: this.caster,
                            killAwarded: false
                        };
                    }
                });

                for(let i = 0; i < this.maxRadius / 2; i++) { 
                    particles.push(new Particle(this.x, this.y, this.team, true, 'poison')); 
                }
            }
            update() { this.duration -= 1 * gameSpeed; return this.duration > 0; }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.max(0, this.duration / this.maxDuration);
                const currentRadius = this.maxRadius * progress;
                ctx.fillStyle = this.team === 1 ? `rgba(132, 204, 22, ${alpha * 0.5})` : `rgba(202, 138, 4, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class SlashAnimation {
            constructor(caster) {
                this.caster = caster;
                this.angle = Math.atan2(caster.target.y - caster.y, caster.target.x - caster.x);
                this.radius = caster.attackRange * 1.5;
                this.duration = 15;
                this.maxDuration = 15;
            }
            update() {
                this.duration -= 1 * gameSpeed;
                if (this.duration > this.maxDuration / 2 && Math.random() > 0.5) {
                    const progress = 1 - (this.duration / this.maxDuration);
                    const arcWidth = Math.PI / 1.5;
                    const particleAngle = this.angle - arcWidth / 2 + (arcWidth * progress);
                    const pX = this.caster.x + Math.cos(particleAngle) * this.radius;
                    const pY = this.caster.y + Math.sin(particleAngle) * this.radius;
                    particles.push(new Particle(pX, pY, this.caster.team));
                }
                return this.duration > 0;
            }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.sin(progress * Math.PI); 
                const arcWidth = Math.PI / 1.5;
                ctx.save();
                ctx.translate(this.caster.x, this.caster.y);
                ctx.rotate(this.angle - arcWidth / 2);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, arcWidth * progress);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.lineWidth = 1 + (3 * alpha);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        class ThrustAnimation {
            constructor(caster, target) {
                this.caster = caster;
                this.target = target;
                this.angle = Math.atan2(target.y - caster.y, target.x - caster.x);
                this.duration = 15;
                this.maxDuration = 15;
                for(let i = 0; i < 5; i++) {
                    particles.push(new Particle(this.target.x, this.target.y, this.caster.team, true));
                }
            }
            update() {
                this.duration -= 1 * gameSpeed;
                return this.duration > 0;
            }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.sin(progress * Math.PI);
                const startX = this.caster.x + Math.cos(this.angle) * this.caster.width/2;
                const startY = this.caster.y + Math.sin(this.angle) * this.caster.width/2;
                const endX = this.target.x - Math.cos(this.angle) * this.target.width/2;
                const endY = this.target.y - Math.sin(this.angle) * this.target.width/2;
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        class AoeExplosion {
            constructor(x, y, radius, damage, team, allUnits, caster) {
                this.x = x; this.y = y; this.maxRadius = radius;
                this.duration = 40; this.maxDuration = 40;
                const enemies = allUnits.filter(u => u.team !== team);
                enemies.forEach(unit => {
                    if (getDistance(this, unit) <= this.maxRadius) {
                        unit.takeDamage(damage, caster);
                    }
                });
                for(let i = 0; i < 30; i++) { particles.push(new Particle(this.x, this.y, team, true, 'fire')); }
            }
            update() { this.duration -= 1 * gameSpeed; return this.duration > 0; }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.max(0, this.duration / this.maxDuration);
                const currentRadius = this.maxRadius * progress;
                ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                if (progress < 1) {
                    ctx.strokeStyle = `rgba(255, 165, 0, ${alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.maxRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        class AoeHeal {
            constructor(x, y, radius, healAmount, team, allUnits, caster, armorBonus, armorDuration, isLightHeal = false) {
                this.x = x; this.y = y;
                this.maxRadius = isLightHeal ? radius * 1.2 : radius;
                this.duration = 80; this.maxDuration = 80;
                this.isLightHeal = isLightHeal;
                
                allUnits.forEach(unit => { 
                    if (unit.team === team && getDistance(this, unit) <= this.maxRadius) {
                        if (unit.hp < unit.maxHp) {
                            let actualHeal = Math.min(unit.maxHp - unit.hp, healAmount);
                            if(unit.buffs.healingReduced) {
                                actualHeal *= (1 - unit.buffs.healingReduced.amount);
                            }
                            unit.hp += actualHeal;
                            caster.healingDone += actualHeal;
                            animations.push(new FloatingText(`+${Math.round(actualHeal)}`, unit.x, unit.y, this.isLightHeal ? '#fef08a' : '#facc15'));
                        }
                        if(this.isLightHeal && armorBonus > 0) {
                            unit.armor = Math.min(unit.maxHp, unit.armor + armorBonus);
                            unit.buffs.armor = { 
                                expires: Date.now() + armorDuration,
                                duration: armorDuration
                            };
                             animations.push(new FloatingText(`+${Math.round(armorBonus)}`, unit.x, unit.y - 15, '#67e8f9'));
                        }
                    }
                });
            }
            update() { this.duration -= 1 * gameSpeed; return this.duration > 0; }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const currentRadius = this.maxRadius * progress;
                const alpha = Math.sin(progress * Math.PI);
                const color = this.isLightHeal ? `rgba(254, 240, 138, ${alpha * 0.9})` : `rgba(250, 204, 21, ${alpha * 0.8})`;
                const lineWidth = this.isLightHeal ? 6 : 4;

                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2); 
                ctx.stroke();

                if (this.isLightHeal) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, currentRadius * 0.8, 0, Math.PI * 2); 
                    ctx.stroke();
                }
            }
        }

         class MultiHealAura {
            constructor(caster, allUnits) {
                this.caster = caster;
                this.specs = UNIT_SPECS.druid;
                this.duration = this.specs.multiHealDuration;
                this.maxDuration = this.specs.multiHealDuration;
                this.targets = [];

                const potentialTargets = allUnits.filter(u => u.team === caster.team && u !== caster && u.hp < u.maxHp);
                potentialTargets.sort((a,b) => getDistance(caster, a) - getDistance(caster, b));

                this.targets = potentialTargets.slice(0, this.specs.multiHealTargets);
                
                this.targets.forEach(target => {
                    target.buffs.druidHeal = {
                        caster: this.caster,
                        healPerTick: this.specs.multiHealAmount,
                        expires: Date.now() + this.specs.multiHealDuration,
                        healedSinceLastText: 0,
                        nextTextTime: Date.now() + 1000
                    };
                });
            }
            update() {
                this.duration -= 1000/60 * gameSpeed;
                if (this.duration <= 0) {
                    this.targets.forEach(t => {
                        if (t.buffs.druidHeal && t.buffs.druidHeal.caster === this.caster) {
                            delete t.buffs.druidHeal;
                        }
                    });
                    return false;
                }
                return true;
            }
            draw() {
                if (this.caster.hp <= 0) return;
                const alpha = Math.max(0, this.duration / this.maxDuration);
                this.targets.forEach(target => {
                    if (target.hp > 0) {
                         ctx.beginPath();
                         ctx.moveTo(this.caster.x, this.caster.y);
                         ctx.lineTo(target.x, target.y);
                         ctx.strokeStyle = `rgba(74, 222, 128, ${0.1 + alpha * 0.2})`;
                         ctx.lineWidth = 6;
                         ctx.stroke();
                         ctx.strokeStyle = `rgba(134, 239, 172, ${0.3 + alpha * 0.3})`;
                         ctx.lineWidth = 2;
                         ctx.stroke();
                         if (Math.random() < 0.2) {
                            particles.push(new Particle(target.x, target.y, this.caster.team, false, 'heal'))
                         }
                    }
                });
            }
        }

        class GroundSmashAnimation {
            constructor(caster, radius, damage, stunDuration, allUnits) {
                this.caster = caster;
                this.x = caster.x;
                this.y = caster.y;
                this.maxRadius = radius;
                this.duration = 60;
                this.maxDuration = 60;
                
                this.caster.isSmashing = true;
                this.caster.smashAnimProgress = this.caster.smashAnimDuration;

                const enemies = allUnits.filter(u => u.team !== caster.team);
                enemies.forEach(unit => {
                    if (getDistance(this, unit) <= this.maxRadius) {
                        unit.takeDamage(damage, caster);
                        unit.stunnedUntil = Date.now() + stunDuration;
                    }
                });
                for(let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * this.maxRadius;
                    const pX = this.x + Math.cos(angle) * dist;
                    const pY = this.y + Math.sin(angle) * dist;
                    particles.push(new Particle(pX, pY, caster.team, false, 'rock'));
                }
            }
            update() { this.duration -= 1 * gameSpeed; return this.duration > 0; }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.max(0, this.duration / this.maxDuration);
                const currentRadius = this.maxRadius * progress;
                
                ctx.strokeStyle = `rgba(168, 162, 158, ${alpha * 0.8})`;
                ctx.lineWidth = 5 * alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        class TrollSmashAnimation extends GroundSmashAnimation {
            constructor(caster, radius, damage, stunDuration, knockback, allUnits) {
                super(caster, radius, 0, stunDuration, allUnits); // Pass 0 for damage to handle it specially
                const specs = UNIT_SPECS.troll;
                const enemies = allUnits.filter(u => u.team !== caster.team);
                enemies.forEach(unit => {
                    if (getDistance(this, unit) <= this.maxRadius) {
                        unit.takeDamage(damage, caster, true); // true for ignoresArmor
                        
                        const angle = Math.atan2(unit.y - this.y, unit.x - this.x);
                        const targetX = unit.x + Math.cos(angle) * knockback;
                        const targetY = unit.y + Math.sin(angle) * knockback;
                        const unitRadius = unit.width / 2;

                        unit.knockbackTargetX = Math.max(unitRadius, Math.min(targetX, canvas.width - unitRadius));
                        unit.knockbackTargetY = Math.max(unitRadius, Math.min(targetY, canvas.height - unitRadius));
                        unit.isBeingKnockedBack = true;
                        
                        unit.buffs.slow = {
                            expires: Date.now() + specs.smashSlowDuration,
                            amount: specs.smashSlowAmount
                        };
                    }
                });
            }
        }

        class ShiverWaveAnimation {
            constructor(caster, allUnits, waveDamage, freezeStacksApplied) {
                this.caster = caster;
                this.specs = UNIT_SPECS.cryomancer;
                this.angle = caster.target ? Math.atan2(caster.target.y - caster.y, caster.target.x - caster.x) : (caster.team === 1 ? 0 : Math.PI);
                this.duration = 80;
                this.maxDuration = 80;
                this.hitUnits = [];
                this.waveDamage = waveDamage;
                this.freezeStacksApplied = freezeStacksApplied;
            }
            update() {
                this.duration -= 1 * gameSpeed;
                
                const enemies = units.filter(u => u.team !== this.caster.team);
                const waveProgress = 1 - (this.duration / this.maxDuration);
                const currentDist = this.specs.attackRange * waveProgress;

                if (this.duration > 0) {
                    const particleAngle = this.angle - (Math.PI / 6) + (Math.random() * Math.PI / 3);
                    const pX = this.caster.x + Math.cos(particleAngle) * currentDist;
                    const pY = this.caster.y + Math.sin(particleAngle) * currentDist;
                    particles.push(new Particle(pX, pY, this.caster.team, false, 'ice'));
                }

                enemies.forEach(enemy => {
                    if (this.hitUnits.includes(enemy.id)) return;

                    const d = getDistance(this.caster, enemy);
                    if (d < currentDist && d > currentDist - 40) {
                        const angleToEnemy = Math.atan2(enemy.y - this.caster.y, enemy.x - this.caster.x);
                        let angleDiff = Math.abs(this.angle - angleToEnemy);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;

                        if (angleDiff < (Math.PI / 4)) {
                            this.hitUnits.push(enemy.id);
                            enemy.takeDamage(this.waveDamage, this.caster);
                            
                            enemy.coldStacks = (enemy.coldStacks || 0) + this.freezeStacksApplied;
                            enemy.buffs.chilled = { expires: Date.now() + this.specs.chillDuration };

                            if (enemy.coldStacks >= this.specs.freezeTriggerCount) {
                                enemy.coldStacks = 0;
                                delete enemy.buffs.chilled;
                                enemy.stunnedUntil = Date.now() + this.specs.freezeDuration;
                                enemy.stunType = 'freeze';
                                for(let i=0; i<25; i++) particles.push(new Particle(enemy.x, enemy.y, this.caster.team, true, 'snow'));
                            }
                        }
                    }
                });

                return this.duration > 0;
            }
            draw() {
                const progress = 1 - (this.duration / this.maxDuration);
                const currentRadius = this.specs.attackRange * progress;
                const alpha = Math.sin(progress * Math.PI);
                
                ctx.save();
                ctx.translate(this.caster.x, this.caster.y);
                ctx.rotate(this.angle);
                
                const coneAngle = Math.PI / 4;

                const gradient = ctx.createRadialGradient(0, 0, currentRadius * 0.7, 0, 0, currentRadius);
                gradient.addColorStop(0, `rgba(165, 243, 252, ${alpha * 0.05})`);
                gradient.addColorStop(1, `rgba(103, 232, 249, ${alpha * 0.4})`);
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.arc(0, 0, currentRadius, -coneAngle, coneAngle);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, -coneAngle, coneAngle);
                ctx.strokeStyle = `rgba(224, 242, 254, ${alpha * 0.7})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class ChainLightning {
            constructor(caster, initialTarget, allUnits) {
                this.caster = caster;
                this.duration = 30;
                this.maxDuration = 30;
                this.team = caster.team;

                const specs = UNIT_SPECS.wizard;
                this.targets = [initialTarget];
                let lastTarget = initialTarget;

                const potentialTargets = allUnits.filter(u => u.team !== this.team && u.hp > 0 && !this.targets.includes(u));

                for (let i = 0; i < specs.chainTargets - 1; i++) {
                    let nextTarget = null;
                    let minDistance = specs.chainRange;
                    for (const p of potentialTargets) {
                        const d = getDistance(lastTarget, p);
                        if (d < minDistance) {
                            minDistance = d;
                            nextTarget = p;
                        }
                    }
                    if (nextTarget) {
                        this.targets.push(nextTarget);
                        potentialTargets.splice(potentialTargets.indexOf(nextTarget), 1);
                        lastTarget = nextTarget;
                    } else {
                        break;
                    }
                }

                this.targets.forEach(target => {
                    target.takeDamage(specs.attackDamage, this.caster);
                });
            }

            update() {
                this.duration -= 1 * gameSpeed;
                if (Math.random() < 0.8) {
                    const from = this.caster;
                    const to = this.targets[0];
                    const p = Math.random();
                    const x = from.x + (to.x - from.x) * p;
                    const y = from.y + (to.y - from.y) * p;
                    particles.push(new Particle(x, y, this.team, false, 'electric'));

                    for (let i = 0; i < this.targets.length - 1; i++) {
                        const p = Math.random();
                        const x = this.targets[i].x + (this.targets[i+1].x - this.targets[i].x) * p;
                        const y = this.targets[i].y + (this.targets[i+1].y - this.targets[i].y) * p;
                        particles.push(new Particle(x, y, this.team, false, 'electric'));
                    }
                }
                return this.duration > 0;
            }

            draw() {
                const alpha = Math.max(0, this.duration / this.maxDuration);
                
                ctx.save();
                ctx.filter = 'blur(4px)';
                ctx.strokeStyle = `rgba(139, 92, 246, ${alpha * 0.5})`;
                ctx.lineWidth = 7;
                drawLightningBolt(this.caster.x, this.caster.y, this.targets[0].x, this.targets[0].y, 10);
                ctx.stroke();
                for (let i = 0; i < this.targets.length - 1; i++) {
                    drawLightningBolt(this.targets[i].x, this.targets[i].y, this.targets[i + 1].x, this.targets[i + 1].y, 10);
                    ctx.stroke();
                }
                ctx.restore();

                ctx.strokeStyle = `rgba(224, 231, 255, ${alpha})`;
                ctx.lineWidth = 2;
                drawLightningBolt(this.caster.x, this.caster.y, this.targets[0].x, this.targets[0].y, 10);
                ctx.stroke();
                for (let i = 0; i < this.targets.length - 1; i++) {
                    drawLightningBolt(this.targets[i].x, this.targets[i].y, this.targets[i + 1].x, this.targets[i + 1].y, 10);
                    ctx.stroke();
                }
            }
        }


        class AuraBuffAnimation {
            constructor(caster, radius, damageBoost, attackSpeedBoost, buffDuration, allUnits) {
                this.caster = caster;
                this.maxRadius = radius;
                this.duration = 60;
                this.maxDuration = 60;

                const allies = allUnits.filter(u => u.team === caster.team);
                allies.forEach(unit => {
                    if (getDistance(this.caster, unit) <= this.maxRadius) {
                        unit.buffs.bard = {
                            expires: Date.now() + buffDuration,
                            damageBoost: damageBoost,
                            attackSpeedBoost: attackSpeedBoost
                        };
                    }
                });
                if(Math.random() < 0.25) {
                    particles.push(new Particle(this.caster.x, this.caster.y - 15, this.caster.team, false, 'music'));
                }
            }
            update() { this.duration -= 1 * gameSpeed; return this.duration > 0; }
            draw() {
                if (this.caster.hp <= 0) return;
                const progress = 1 - (this.duration / this.maxDuration);
                const alpha = Math.sin(progress * Math.PI);
                
                ctx.strokeStyle = `rgba(167, 139, 250, ${alpha * 0.6})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.caster.x, this.caster.y, this.maxRadius * progress, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text; this.x = x; this.y = y; this.color = color;
                this.lifespan = 60; this.maxLifespan = 60; this.vy = -0.5;
            }
            update() { this.y += this.vy * gameSpeed; this.lifespan -= 1 * gameSpeed; return this.lifespan > 0; }
            draw() {
                const alpha = Math.max(0, this.lifespan / this.maxLifespan);
                ctx.font = 'bold 16px "Roboto Mono"';
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('#', 'rgba(' + parseInt(this.color.slice(1,3), 16) + ',' + parseInt(this.color.slice(3,5), 16) + ',' + parseInt(this.color.slice(5,7), 16) + `, ${alpha})`);
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
            }
        }

        class Particle {
            constructor(x, y, team, isImpact = false, type = 'generic') {
                this.x = x; this.y = y; this.type = type;
                if (isImpact) {
                    this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4;
                    this.lifespan = 10 + Math.random() * 10;
                } else {
                    this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 2;
                    this.lifespan = 20 + Math.random() * 20;
                }
                this.maxLifespan = this.lifespan; this.size = 1 + Math.random() * 2.5;
                this.gravity = 0;

                if(this.type === 'fire') {
                    const colors = ['rgba(255, 100, 0,', 'rgba(255, 165, 0,', 'rgba(255, 69, 0,'];
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                } else if (this.type === 'rock') {
                    const colors = ['rgba(120, 113, 108,', 'rgba(168, 162, 158,'];
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = Math.random() * -2;
                    this.size = 2 + Math.random() * 3;
                } else if (this.type === 'music') {
                    this.color = 'rgba(255, 255, 255,';
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = -0.5 - Math.random() * 0.5;
                    this.lifespan = 40 + Math.random() * 20;
                    this.maxLifespan = this.lifespan;
                    this.char = ['', ''][Math.floor(Math.random() * 2)];
                } else if (this.type === 'electric') {
                    this.color = ['rgba(191, 219, 254,', 'rgba(224, 231, 255,', 'rgba(99, 102, 241,'][Math.floor(Math.random() * 3)];
                    this.vx = (Math.random() - 0.5) * 6;
                    this.vy = (Math.random() - 0.5) * 6;
                    this.lifespan = 5 + Math.random() * 8;
                    this.size = 1 + Math.random() * 1.5;
                } else if (this.type === 'ice') {
                    this.color = ['rgba(207, 250, 254,', 'rgba(165, 243, 252,'][Math.floor(Math.random() * 2)];
                    this.vy = (Math.random() - 0.5) * 1;
                    this.vx = (Math.random() - 0.5) * 1;
                    this.lifespan = 20 + Math.random() * 20;
                } else if (this.type === 'poison') {
                    this.color = ['rgba(132, 204, 22,', 'rgba(163, 230, 53,'][Math.floor(Math.random() * 2)];
                    this.vy = -0.5 - (Math.random() * 0.5);
                    this.vx = (Math.random() - 0.5) * 1;
                    this.lifespan = 30 + Math.random() * 20;
                    this.size = 2 + Math.random() * 2;
                } else if (this.type === 'snow') {
                    this.color = 'rgba(255, 255, 255,';
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = 0.2 + Math.random() * 0.4;
                    this.size = 1 + Math.random() * 2;
                    this.lifespan = 60 + Math.random() * 60;
                } else if (this.type === 'heal') {
                    this.color = 'rgba(74, 222, 128,';
                    this.vy = -0.2 - Math.random() * 0.3;
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.lifespan = 30 + Math.random() * 15;
                }else {
                    this.color = team === 1 ? 'rgba(255, 255, 255,' : 'rgba(255, 255, 255,';
                }
            }
            update() { this.vy += this.gravity * gameSpeed; this.x += this.vx * gameSpeed; this.y += this.vy * gameSpeed; this.lifespan -= 1 * gameSpeed; return this.lifespan > 0; }
            draw() {
                if (this.type === 'music') {
                    const alpha = Math.max(0, this.lifespan / this.maxLifespan);
                    ctx.font = 'bold 18px "Roboto Mono"';
                    ctx.fillStyle = `rgba(236, 233, 253, ${alpha})`;
                    ctx.textAlign = 'center';
                    ctx.fillText(this.char, this.x, this.y);
                } else {
                    const alpha = Math.max(0, this.lifespan / this.maxLifespan);
                    ctx.fillStyle = this.color + `${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function update() {
            if (!isBattleStarted) return;
            const team1Units = units.filter(u => u.team === 1);
            const team2Units = units.filter(u => u.team === 2);
            units.forEach(unit => unit.update(unit.team === 1 ? team1Units : team2Units, unit.team === 1 ? team2Units : team1Units));
            projectiles = projectiles.filter(p => p.update(p.team === 1 ? team2Units : team1Units));
            animations = animations.filter(a => a.update());
            particles = particles.filter(p => p.update());
            const unitsAliveBefore = units.length;
            units = units.filter(u => u.hp > 0);
            if (units.length < unitsAliveBefore) updateUnitCounts();
            const team1Alive = units.some(u => u.team === 1);
            const team2Alive = units.some(u => u.team === 2);
            if ((team1Units.length > 0 || team2Units.length > 0) && isBattleStarted) {
                if (team1Alive && !team2Alive && team2Units.length > 0) endBattle("Blue Team Wins!");
                else if (!team1Alive && team2Alive && team1Units.length > 0) endBattle("Red Team Wins!");
                else if (!team1Alive && !team2Alive && team1Units.length > 0 && team2Units.length > 0) endBattle("Draw!");
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fillRect(0, 0, canvas.width / 3, canvas.height);
            ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            ctx.fillRect(canvas.width - canvas.width / 3, 0, canvas.width / 3, canvas.height);

            if (showRangePreview && !isInspectModeActive) {
                units.forEach(unit => {
                    const specs = UNIT_SPECS[unit.type];
                    let range = specs.attackRange;
                    let color = unit.team === 1 ? '#60a5fa' : '#f87171';
                    if (unit.type === 'priest' || unit.type === 'druid') { range = specs.healRadius || specs.attackRange; color = '#facc15'; }
                    if (unit.type === 'bard') { range = specs.buffRadius; color = '#a78bfa'; }
                    if (range > 0) {
                        ctx.beginPath();
                        ctx.arc(unit.x, unit.y, range, 0, Math.PI * 2);
                        ctx.globalAlpha = 0.10;
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 10]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1.0;
                    }
                });
            }
            
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            animations.forEach(a => a.draw());
            units.forEach(unit => unit.draw());
            
            if (selectedUnit && mousePos.onCanvas && !isBattleStarted) {
                const specs = UNIT_SPECS[selectedUnit];
                ctx.fillStyle = (mousePos.x < canvas.width / 3) ? specs.color.team1 : specs.color.team2;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 10, 0, Math.PI * 2);
                ctx.fill();
                let range = specs.attackRange;
                if (specs.healRadius) range = specs.healRadius;
                if (specs.buffRadius) range = specs.buffRadius;
                if (showRangePreview && range > 0) {
                    ctx.beginPath();
                    ctx.arc(mousePos.x, mousePos.y, range, 0, Math.PI * 2);
                    ctx.setLineDash([8, 12]);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                ctx.globalAlpha = 1.0;
            }

            const unitUnderMouse = trackedUnit || (isInspectModeActive && unitToHighlight) || (isRemoveModeActive && unitToHighlight);
            if(unitUnderMouse) {
                const isInspecting = isInspectModeActive || trackedUnit;
                const highlightColor = isInspecting ? 'rgba(167, 139, 250, 0.8)' : 'rgba(239, 68, 68, 0.8)';
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.arc(unitUnderMouse.x, unitUnderMouse.y, unitUnderMouse.width / 2 + 8, 0, Math.PI * 2);
                ctx.fillStyle = highlightColor.replace('0.8', '0.7');
                ctx.filter = 'blur(8px)';
                ctx.fill();
                ctx.restore();
                ctx.beginPath();
                ctx.arc(unitUnderMouse.x, unitUnderMouse.y, unitUnderMouse.width / 2 + 4, 0, Math.PI * 2);
                ctx.strokeStyle = highlightColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                const specs = UNIT_SPECS[unitUnderMouse.type];
                let range = specs.attackRange;
                if (specs.healRadius) range = specs.healRadius;
                if (specs.buffRadius) range = specs.buffRadius;
                if (isInspecting && range > 0) {
                    ctx.beginPath();
                    ctx.arc(unitUnderMouse.x, unitUnderMouse.y, range, 0, Math.PI * 2);
                    ctx.setLineDash([8, 12]);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            if (isPaused && isBattleStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '50px "Roboto Mono"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameLoop() {
            if (!isPaused) { 
                update(); 
                statsUpdateCounter++;
                if (isBattleStarted && document.getElementById('stats-panel').classList.contains('open') && statsUpdateCounter >= STATS_UPDATE_INTERVAL) {
                    updateStatsPanel();
                    statsUpdateCounter = 0;
                }
            }
            draw();
            if(trackedUnit) updateInspectTooltip(trackedUnit);
            requestAnimationFrame(gameLoop);
        }

        function setup() {
            initialUnitPlacement = [];
            isBattleStarted = false; isPaused = false; gameSpeed = 1.0;
            isRemoveModeActive = false;
            isInspectModeActive = false;
            trackedUnit = null;
            nextUnitId = 0;
            statsFilter = 'all';
            isSummarizedView = false;
            
            document.getElementById('remove-unit-btn').classList.remove('active');
            document.getElementById('inspect-unit-btn').classList.remove('active');
            document.getElementById('stop-tracking-btn').classList.add('hidden');

            canvas.style.cursor = 'crosshair';
            startBattleBtn.innerHTML = playIconSVG;
            pauseBtn.innerHTML = pauseIconSVG;
            document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('selected'));
            document.querySelector('.speed-btn[data-speed="1.0"]').classList.add('selected');
            units = []; allUnitsThisRound = []; projectiles = []; animations = []; particles = [];
            updateUnitCounts();
            selectedUnit = null;
            document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.unit-btn').forEach(b => b.disabled = false);
            statusMessage.style.opacity = 0; statusMessage.textContent = '';
            selectionMessage.style.opacity = 0; selectionMessage.textContent = '';
            document.getElementById('remove-message').style.opacity = 0;
            document.getElementById('inspect-message').style.opacity = 0;
            unitToHighlight = null;
            document.getElementById('stats-panel-content').innerHTML = '';
        }
        
        function resetBattlefield() {
            isBattleStarted = false;
            isPaused = false;
            projectiles = []; animations = []; particles = [];
            units = []; allUnitsThisRound = []; nextUnitId = 0;
            if (initialUnitPlacement.length > 0) {
                initialUnitPlacement.forEach(proto => {
                    const newUnit = new Unit(proto.x, proto.y, proto.team, proto.type, proto.relX, proto.relY);
                    units.push(newUnit);
                    allUnitsThisRound.push(newUnit);
                });
            }
            startBattleBtn.innerHTML = playIconSVG;
            pauseBtn.innerHTML = pauseIconSVG;
            document.querySelectorAll('.unit-btn').forEach(b => b.disabled = false);
            statusMessage.style.opacity = 0;
            statusMessage.textContent = '';
            updateUnitCounts();
        }

        function updateUnitCounts() {
            blueCountDisplay.textContent = units.filter(u => u.team === 1).length;
            redCountDisplay.textContent = units.filter(u => u.team === 2).length;
        }

        function endBattle(message) {
             isBattleStarted = false; statusMessage.textContent = message;
             statusMessage.style.opacity = 1;
             startBattleBtn.innerHTML = playIconSVG;
             if (document.getElementById('stats-panel').classList.contains('open')) updateStatsPanel();
        }
        
        function selectUnit(type) {
             if (isRemoveModeActive || isInspectModeActive) return;
             if (selectedUnit === type) {
                selectedUnit = null;
                document.querySelector(`[data-unit-type="${type}"]`).classList.remove('selected');
                selectionMessage.style.opacity = 0;
                return;
             }
             selectedUnit = type;
             document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
             document.querySelector(`[data-unit-type="${type}"]`).classList.add('selected');
             selectionMessage.textContent = 'Currently selecting: ' + UNIT_SPECS[type].name;
             selectionMessage.style.opacity = 1;
        }

        // === MAIN SCRIPT INITIALIZATION ===

        window.addEventListener('resize', resizeCanvas);
        
        document.querySelectorAll('.unit-btn').forEach(btn => {
            const unitType = btn.dataset.unitType;
            btn.addEventListener('click', () => selectUnit(unitType));
            btn.addEventListener('mouseenter', () => {
                const stats = UNIT_SPECS[unitType];
                if (!stats) return;
                const tagsHTML = stats.tags.map(tag => `<span class="bg-gray-600 text-violet-300 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">${tag}</span>`).join('');
                let statsHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm">
                        <span class="text-gray-400">HP:</span> <span class="text-white">${stats.hp}</span>
                        <span class="text-gray-400">Speed:</span> <span class="text-white">${stats.speed}</span>
                        <span class="text-gray-400">Damage:</span> <span class="text-white">${stats.attackDamage > 0 ? stats.attackDamage : 'N/A'}</span>
                        <span class="text-gray-400">Heal:</span> <span class="text-white">${stats.healAmount > 0 ? stats.healAmount : 'N/A'}</span>
                        <span class="text-gray-400">Cooldown:</span> <span class="text-white">${stats.attackCooldown > 0 ? stats.attackCooldown + 'ms' : 'N/A'}</span>
                    </div>`;
                tooltip.innerHTML = `
                    <h3 class="text-lg font-bold text-violet-300 mb-2">${stats.name}</h3>
                    ${statsHTML}
                    <div class="mt-3 pt-2 border-t border-gray-600">
                        ${tagsHTML}
                    </div>
                `;
                tooltip.style.display = 'block';
            });
            btn.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        });

        document.addEventListener('mousemove', (e) => {
            if (tooltip.style.display === 'block') {
                tooltip.style.left = `${e.clientX + 15}px`;
                tooltip.style.top = `${e.clientY + 15}px`;
            }
        });

        document.querySelectorAll('[data-tooltip-title]').forEach(el => {
            el.addEventListener('mouseenter', (e) => {
                const title = el.dataset.tooltipTitle;
                const desc = el.dataset.tooltipDesc;
                tooltip.innerHTML = `
                    <h3 class="text-lg font-bold text-violet-300 mb-2">${title}</span>
                    <p class="text-sm text-gray-300">${desc}</p>
                `;
                tooltip.style.display = 'block';
            });
            el.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left; 
            const y = e.clientY - rect.top;

            if (isRemoveModeActive) {
                let unitToRemove = null;
                let closestDist = Infinity;
                units.forEach(unit => {
                    const dist = getDistance({x, y}, unit);
                    if (dist < unit.width / 2 + 5 && dist < closestDist) {
                        unitToRemove = unit;
                        closestDist = dist;
                    }
                });
                if (unitToRemove) {
                    units = units.filter(u => u !== unitToRemove);
                    allUnitsThisRound = allUnitsThisRound.filter(u => u.id !== unitToRemove.id);
                    updateUnitCounts();
                    unitToHighlight = null;
                }
                return;
            }
            
            if (isInspectModeActive) {
                let unitToTrack = null;
                let closestDist = Infinity;
                units.forEach(unit => {
                    const dist = getDistance({x, y}, unit);
                    if (dist < unit.width / 2 + 5 && dist < closestDist) {
                        unitToTrack = unit;
                        closestDist = dist;
                    }
                });
                if (unitToTrack) {
                    if (trackedUnit === unitToTrack) {
                        trackedUnit = null;
                        document.getElementById('stop-tracking-btn').classList.add('hidden');
                        document.getElementById('inspect-message').style.opacity = 1;
                    } else {
                        trackedUnit = unitToTrack;
                        document.getElementById('stop-tracking-btn').classList.remove('hidden');
                        document.getElementById('inspect-message').style.opacity = 0;
                    }
                }
                return;
            }

            if (isBattleStarted || !selectedUnit || isPaused) return;

            const relX = x / canvas.width; const relY = y / canvas.height;
            let newUnit;
            if (x < canvas.width / 3) {
                 newUnit = new Unit(x, y, 1, selectedUnit, relX, relY);
                 units.push(newUnit);
                 allUnitsThisRound.push(newUnit);
            } else if (x > canvas.width - canvas.width / 3) {
                 newUnit = new Unit(x, y, 2, selectedUnit, relX, relY);
                 units.push(newUnit);
                 allUnitsThisRound.push(newUnit);
            }
            updateUnitCounts();
        });
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top;
            mousePos.onCanvas = true;
            unitToHighlight = null; 
            let closestDist = Infinity;
            for (const unit of units) {
                const dist = getDistance(mousePos, unit)
                if (dist < unit.width / 2 + 5 && dist < closestDist) {
                    unitToHighlight = unit;
                    closestDist = dist;
                }
            }
            if (isInspectModeActive && unitToHighlight && !trackedUnit) {
                updateInspectTooltip(unitToHighlight, e);
            } else if (!trackedUnit) {
                document.getElementById('inspect-tooltip').style.display = 'none';
            }
        });

        canvas.addEventListener('mouseleave', () => { 
            mousePos.onCanvas = false; 
            unitToHighlight = null;
            if (!trackedUnit) document.getElementById('inspect-tooltip').style.display = 'none';
        });

        startBattleBtn.addEventListener('click', () => {
            if (isBattleStarted) {
                endBattle("Battle Stopped");
                setup();
                return;
            }
            if (units.length === 0) return;
            initialUnitPlacement = units.map(u => ({ x: u.x, y: u.y, team: u.team, type: u.type, relX: u.relX, relY: u.relY }));
            if (isPaused) { isPaused = false; pauseBtn.innerHTML = pauseIconSVG; }
            isBattleStarted = true;
            startBattleBtn.innerHTML = stopIconSVG;
            document.querySelectorAll('.unit-btn').forEach(b => b.disabled = true);
            isRemoveModeActive = false;
            document.getElementById('remove-unit-btn').classList.remove('active');
            document.getElementById('remove-message').style.opacity = 0;
            unitToHighlight = null;
            canvas.style.cursor = 'crosshair';
            selectedUnit = null;
            selectionMessage.style.opacity = 0;
            document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
        });

        pauseBtn.addEventListener('click', () => {
            if (!isBattleStarted) return;
            isPaused = !isPaused;
            pauseBtn.innerHTML = isPaused ? playIconSVG : pauseIconSVG;
        });

        speedControls.addEventListener('click', (e) => {
            const speedBtn = e.target.closest('.speed-btn');
            if (speedBtn) {
                gameSpeed = parseFloat(speedBtn.dataset.speed);
                document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('selected'));
                speedBtn.classList.add('selected');
            }
        });

        resetBtn.addEventListener('click', resetBattlefield);

        roleSorter.addEventListener('click', (e) => {
            const roleBtn = e.target.closest('.role-btn');
            if (roleBtn) {
                const selectedRole = roleBtn.dataset.role;
                document.querySelectorAll('.role-btn').forEach(btn => btn.classList.remove('selected'));
                roleBtn.classList.add('selected');
                document.querySelectorAll('.unit-btn').forEach(unitBtn => {
                    if (selectedRole === 'all') {
                        unitBtn.style.display = 'block';
                    } else {
                        const unitType = unitBtn.dataset.unitType;
                        const unitTags = UNIT_SPECS[unitType].tags;
                        unitBtn.style.display = unitTags.includes(selectedRole) ? 'block' : 'none';
                    }
                });
            }
        });

        // Initialize everything
        initInteractionEventListeners();
        initStatsEventListeners();
        initHotkeys();
        resizeCanvas();
        setup();
        const eyeIcon = document.getElementById('eye-icon');
        const eyeOffIcon = document.getElementById('eye-off-icon');
        eyeIcon.classList.toggle('hidden', !showRangePreview);
        eyeOffIcon.classList.toggle('hidden', showRangePreview);
        gameLoop();
    </script>
</body>
</html>
